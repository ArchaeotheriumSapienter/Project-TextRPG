"""
File: rpgame.py
-------------------------
This is a simple RPG program where a player can choose various actions and fight enemies

Milestone:
1. Prompt welcome message - done
2. Input Name - done
2. Finish introduction - done
3. Create character - done
4. Make character move, attack, defend - done
    a. make a set of moves that a player can do:
        - move done
        - attack not yet
        -
5. Make an enemy - done
6. Random occurence of enemy when player is walking - done
6. Make enemy fight the character - done
8. Make a scripted enemy
9. continue storyline
"""

import random  # used for moving and random events in the game
import sys  # used for the text effect
import time  # used to delay the texts for a few miliseconds

BOSS_NAME = '⊑⟒⍀?'
ENEMY_POSSIBILITY = 5  # constant for random_enemy_occurance based from 1 to an integer for the possibility of an enemy
# spawning
FLEE_POSSIBILITY = 3 # constant for flee function based from 1 to an integer for the possibility of the character
# fleeing
NEXT_TEXT_DURATION = 0.1
INPUT_AND_TEXT_EFFECT_DURATION = 0.001  # 0.05 normal speed


# -----------------------
# Main Function
# -----------------------


def main():
    # values in the classes are (from left to right):
    # name, health, max_health, attack, double_damage, leeching, defense, shield_bubble,
    # ultimate_levelup_bar, ultimate_levelup_bar_per_attack, levelup_bar, levelup_per_defeated_enemy

    #  handler for the character parent class and the minimum value of each stats that a character can have
    handler = Character('', 1, 1, 10, 0, 0, 0, 0, 0, 0, 0, 0)

    # initial stats of the player
    p = Player(50, 50, 10, 0.05, 0, 5, 0, 20, 4, 30, 5)

    # name input to get the name of the player
    p.name = input_print_effect('Before we start, what is your name? ')

    # welcome_message_and_introduction(p.name)
    debug_attack = input('Just Press Enter ')

    while debug_attack == '':
        p.player_commands()
        debug_attack = input('Just Press Enter  ')

    # first_chapter()


# -----------------------
# Functions From Main
# -----------------------


def welcome_message_and_introduction(user_name):
    """
    Welcome message for the user to see and asks the user whether to start the game or not
    Return: user_name
    """
    type_print_effect("Welcome to the Journey.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect('You are an individual that suddenly woke up without any recollection.\n')
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect('Now you must understand what happened before you came to this place.\n')
    time.sleep(NEXT_TEXT_DURATION)

    # Asks the user for an input and the input of the user is turned into a lowercase to clean data
    start_game = input_print_effect('Type y to start or n to end the game ').lower()

    # If argument with the user's choices, if n, it will exit the program, anything other than y or n will
    # be taken as a sign to end the game, and y will prompt to start the introduction function
    while start_game != '':
        if start_game == 'y':
            introduction(user_name)
            break
        elif start_game == 'n':
            print('')  # space for terminal
            type_print_effect('Thank you for taking the time to check out my first Python Project.\n')
            time.sleep(NEXT_TEXT_DURATION)
            type_print_effect('This means a lot to me. Have a great day! :)')
            sys.exit()
        else:
            print('')  # space for terminal
            print('Invalid input. Please press the appropriate letter.')

            # Fencepost solution
            start_game = input_print_effect('Type y to start or n to end the game ').lower()


# def first_chapter():


# -----------------------
# Helper Functions
# -----------------------

#  kulang pa dito YUNG WEAPONS LAGYAN MO MAMAYA
def introduction(user_name):
    """
    Opening dialogue with Alicia, the first character that the player saw, she will guide the player to the dojo
    Pre-condition: Player starts the game
    Post-condition: Player has a name and is headed for the dojo
    """
    print('')  # For spacing from the start menu
    type_print_effect("Hey, wake up! Are you okay? Who are you? And what are you doing near my home!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Oh my, you have so many bruises! Let me tend your wounds and then let's talk.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("I'm Alicia by the way, its a good thing I found you here,\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("there isn't any hospitals or clinic here for hundreds of kilometers.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("The best bet you have right now is me, good thing I have a first aid kit.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("I forgot to even ask! What's your name?\n")

    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("That's a nice name, " + user_name + "\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("There we go, I patched your wounds. The problem now is where would you go?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("And do you remember how you got here? Or who you are?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Hey! What's that in your shoulder, I guess I missed a wound.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("You're one of them!!! I can't believe it. How did you wind up here? In the middle of nowhere?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("You're here to defeat " + BOSS_NAME + "\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("But you can't! You'll get yourself killed!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("But if you're one of them, I guess you're destined towards that goal? Destiny is so weird\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("I mean, who gets to decide what you should do? Is it the player? I guess not...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("The player is only looking at the screen right now, just watching our whole conversation.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Anyway, since I can see that you're one of them, I believe you can still remember how to "
                      "fight?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Or how to use your power? I want to see how you release your power!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Don't you rememeber anything? Come on, just one move!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Oh my, if that's the case, I think you should go to the nearby dojo.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("The sensei there would help you remember the once you've lost\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Before you go! I'll give you this to defend yourself.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("It's no longer safe ever since we've left Earth.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Goodluck out there " + user_name + "\n")


# -----------------------
# Sub-Helper Functions
# -----------------------

def type_print_effect(text):
    """
    This function takes print strings and change them to have a typing effect with the help of time
    sleep so that it has a delay, much like when someone is typing

    Parameter: text - the inputted text where it would be converted to a typing effect
    """

    for character in text:
        print(character, end='')
        sys.stdout.flush()
        time.sleep(INPUT_AND_TEXT_EFFECT_DURATION)


def input_print_effect(text):
    """
    This function is the same with text_print_effect, the difference is that this is used
    when a user inputs something and a message is prompted

    :param: text - the message with the input from the user
    :return: value - the answer that the user gave to be used by other functions
    """
    for character in text:
        print(character, end='')
        sys.stdout.flush()
        time.sleep(INPUT_AND_TEXT_EFFECT_DURATION)
    value = input()
    return value


# -----------------------
# Classes
# -----------------------


class Character:
    """
    Parent Class for all of the stats of each character, as well as the player.
    This also has all the functions that each character can do
    """

    def __init__(self, name, health, max_health, attack, double_damage, leeching, defense, shield_bubble,
                 ultimate_levelup_bar, ultimate_levelup_bar_per_attack, levelup_bar, levelup_per_defeated_enemy):
        self.name = name
        self.health = health
        self.max_health = max_health
        self.attack = attack
        self.double_damage = double_damage
        self.leeching = leeching
        self.defense = defense
        self.shield_bubble = shield_bubble

        # stats for levelling up to gain your ultimate
        self.ultimate_levelup_bar = ultimate_levelup_bar
        self.ultimate_levelup_bar_per_attack = ultimate_levelup_bar_per_attack

        # stats for levelling up your character
        self.levelup_bar = levelup_bar
        self.levelup_per_defeated_enemy = levelup_per_defeated_enemy

    def leeching(self, damage):
        """
        Function for the leeching power in which the damage given by the character is transformed into the
        character's health
        Return: self.health
        """

        # if the current health is less than max health
        if self.health < self.max_health:
            # if the leeching points is less than the damage given, give the value of the self.leeching as the
            # additional health
            if self.leeching <= damage:
                self.health += self.leeching

            # if the self.leeching points is higher than the damage, give the value of the damage as the health
            # points
            elif self.leeching > damage:
                self.health += damage

        # used when the self.health is higher than the maximum health due to leeching
        if self.health > self.max_health:
            surplus_health = self.health - self.max_health
            self.health = self.health - surplus_health

        return self.health

    def do_damage(self, enemy):
        """
        Function for when the player attacks
        :param enemy: To lower the health of the enemy
        """
        # damage of the character
        damage = random.randint(0, self.attack)

        # utilizing the defense, one in three chance that the defense will break
        break_defense_chance = random.randint(1, 3)

        # checks to see if the class that called the method is the player
        if self.__class__ == Player:
            # for aesthetics in terminal
            print("------------------------------------PLAYER'S TURN------------------------------------")
            # if the defenses break
            if break_defense_chance == 1:
                # when the damage is equals to zero
                if damage == 0:
                    type_print_effect(enemy.name + " felt a scratch! " +
                                      self.name + " dealt " + str(damage) + " damage!\n")

                else:
                    # enemy losses health with no defense
                    enemy.health = enemy.health - damage
                    type_print_effect(enemy.name + "'s defense has broken! " +
                                      self.name + " dealt " + str(damage) + " damage!\n")
                    type_print_effect("The " + enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")
            else:
                # if the damage is lower than the defense of the enemy
                if damage <= enemy.defense:
                    type_print_effect(enemy.name + " has defended all of your attack!\n")
                    type_print_effect("The " + enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")

                else:
                    # used when the damage is larger than the defense
                    damage_with_defense = damage - enemy.defense

                    # for debugging only
                    # print(damage_with_defense, "is the damage with defense!")

                    enemy.health = enemy.health - damage_with_defense

                    # for debugging only
                    # print(enemy.health)

                    type_print_effect(enemy.name + " defended a part of your attack! " +
                                      self.name + " dealt " + str(damage) + " damage!\n")
                    type_print_effect("The " + enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")

        # if the caller are the common enemies
        if self.__class__ == DeformedMutatedHuman or self.__class__ == MutatedHuman \
                or self.__class__ == LostWanderer or self.__class__ == Chaser:
            # for aesthetics in terminal
            print("------------------------------------ENEMY'S TURN-------------------------------------")
            # if the defenses break
            if break_defense_chance == 1:
                # when the damage is equals to zero
                if damage == 0:
                    type_print_effect(self.name + " barely scratched " +
                                      enemy.name + "!\n")
                    type_print_effect(enemy.name + "'s Health is: " + str(self.health) + "\n")

                else:
                    # enemy losses health with no defense
                    enemy.health = enemy.health - damage
                    type_print_effect(enemy.name + "'s defense has broken! " +
                                      self.name + " dealt " + str(damage) + " damage!\n")
                    type_print_effect(enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")
            else:
                # if the damage is lower than the defense of the enemy
                if damage <= enemy.defense:
                    type_print_effect(enemy.name + " defended all of " + self.name + " attacks!\n")
                    type_print_effect(enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")

                else:
                    # used when the damage is larger than the defense
                    damage_with_defense = damage - enemy.defense

                    enemy.health = enemy.health - damage_with_defense

                    type_print_effect(enemy.name + " defended a part of " + self.name + " attack! " +
                                      self.name + " dealt " + str(damage) + " damage!\n")
                    type_print_effect(enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")

        print('')  # for spacing in the terminal


# -----------------------
# Enemy Classes
# -----------------------
# Classes of all kinds of enemies that the player will encounter

# ENEMY COMMON CLASS

class DeformedMutatedHuman(Character):
    """
    Subclass of characters, a common enemy
    """

    def __init__(self,
                 name='Deformed Mutated Human',
                 health=10,
                 max_health=10,
                 attack=20,
                 double_damage=None,
                 leeching=None,
                 defense=5,
                 shield_bubble=None,
                 ultimate_levelup_bar=None,
                 ultimate_levelup_bar_per_attack=None,
                 levelup_bar=None,
                 levelup_per_defeated_enemy=None):
        super().__init__(name,
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)


class MutatedHuman(Character):
    """
    Subclass of character, a common enemy
    """

    def __init__(self,
                 name='Mutated Human',
                 health=20,
                 max_health=20,
                 attack=10,
                 double_damage=None,
                 leeching=None,
                 defense=7,
                 shield_bubble=None,
                 ultimate_levelup_bar=None,
                 ultimate_levelup_bar_per_attack=None,
                 levelup_bar=None,
                 levelup_per_defeated_enemy=None):
        super().__init__(name,
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)


class LostWanderer(Character):
    """
    Subclass of character, a common enemy
    """

    def __init__(self,
                 name='Lost Wanderer',
                 health=5,
                 max_health=5,
                 attack=20,
                 double_damage=None,
                 leeching=5,
                 defense=7,
                 shield_bubble=None,
                 ultimate_levelup_bar=None,
                 ultimate_levelup_bar_per_attack=None,
                 levelup_bar=None,
                 levelup_per_defeated_enemy=None):
        super().__init__(name,
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)


class Chaser(Character):
    """
    Subclass of character, a common enemy
    """

    def __init__(self,
                 name='Chaser',
                 health=15,
                 max_health=15,
                 attack=15,
                 double_damage=None,
                 leeching=2,
                 defense=7,
                 shield_bubble=None,
                 ultimate_levelup_bar=None,
                 ultimate_levelup_bar_per_attack=None,
                 levelup_bar=None,
                 levelup_per_defeated_enemy=None):
        super().__init__(name,
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)


# -----------------------
# Player Class
# -----------------------

class Player(Character):
    """
    Subclass of Character and it has all the commands that the player can do
    """

    def __init__(self,
                 health,
                 max_health,
                 attack,
                 double_damage,
                 leeching,
                 defense,
                 shield_bubble,
                 ultimate_levelup_bar,
                 ultimate_levelup_bar_per_attack,
                 levelup_bar,
                 levelup_per_defeated_enemy):

        # grabbed the parent class for inheritance for its functions
        super().__init__("",
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)

        # for the p.name instance to overwrite the values of the parent class
        self.name = ''

        #  double damage converted to percentage for the user to see in the status command
        self.double_damage_percentage = "{0:.2%}".format(double_damage)

    def random_enemy_encounter(self):
        """
        Function for random enemies to fight the player
        """

        # calling all of the common class enemy when the player walks with a one in third chance to encounter them
        deformed_mutated_human = DeformedMutatedHuman()
        mutated_human = MutatedHuman()
        lost_wanderer = LostWanderer()
        chaser = Chaser()

        # each integer is equivalent to one type of enemy
        random_enemy = random.randint(1, 4)

        # if statement to determine what enemy the player will encounter based on the random_enemy integer
        if random_enemy == 1:
            type_print_effect("A " + deformed_mutated_human.name + " has spotted you!\n")
            print('')  # space for terminal
            self.player_commands_attack_mode()
            while attack_debug == '':
                self.do_damage(deformed_mutated_human)
                deformed_mutated_human.do_damage(self)
                attack_debug = input_print_effect("Debugging(Press Enter to attack) ")
        elif random_enemy == 2:
            type_print_effect("A " + mutated_human.name + " screeched as it notices your movement!\n")
            print('')  # space for terminal
            attack_debug = input_print_effect("Debugging(Press Enter to attack) ")
            while attack_debug == '':
                self.do_damage(mutated_human)
                mutated_human.do_damage(self)
                attack_debug = input_print_effect("Debugging(Press Enter to attack) ")
        elif random_enemy == 3:
            type_print_effect("The sound of a " + lost_wanderer.name + " echoed through the wind. And it has "
                                                                       "caught your attention!\n")
            print('')  # space for terminal
            attack_debug = input_print_effect("Debugging(Press Enter to attack) ")
            while attack_debug == '':
                self.do_damage(lost_wanderer)
                lost_wanderer.do_damage(self)
                attack_debug = input_print_effect("Debugging(Press Enter to attack) ")
        elif random_enemy == 4:
            type_print_effect("A vicious " + chaser.name + " has smelled your scent. It suddenly sprinted "
                                                           "towards your direction!\n")
            print('')  # space for terminal
            attack_debug = input_print_effect("Debugging(Press Enter to attack) ")
            while attack_debug == '':
                self.do_damage(chaser)
                chaser.do_damage(self)
                attack_debug = input_print_effect("Debugging(Press Enter to attack) ")

    def attack(self):
        """
        Player attack using the .do_damage then if the player has leeching, call upon .leeching
        """
        pass

        # call upon leeching every time a character attacks and if the character has it
        if self.leeching != 0:
            self.health = self.leeching(self)

    def move(self):
        """
        Function when a player moves, uses random integer to determine the number of steps the player takes
        One out of an integer chance that the player will encounter an enemy while moving
        """
        # probablity for enemy to show up while moving based on the constant
        enemy_possibility = random.randint(1, ENEMY_POSSIBILITY)

        # how many steps the player can take
        number_of_moves = random.randint(1, 10)

        # if the player encounters an enemy
        if enemy_possibility == 1:
            # call upon the random_enemy_encounter to see what enemy the player will face off
            self.random_enemy_encounter()
        elif enemy_possibility == 2:
            type_print_effect(self.name + " has nearly missed an enemy, and has moved " + str(number_of_moves)
                              + " steps.\n")
        elif enemy_possibility == 3:
            type_print_effect(self.name + " sneakily moved " + str(number_of_moves)
                              + " steps away from a monster.\n")
        else:
            type_print_effect(self.name + " has moved " + str(number_of_moves) + " steps.\n")
        print('')  # for spacing in the terminal


    def flee(self):
        """
        A function only found while attack mode is one, a one in integer chance for the character to flee to prevent
        them from dying
        """
        flee_chance = random.randint(1, FLEE_POSSIBILITY)

        if flee_chance == 1:
            type_print_effect("You have successfully escaped")

    def status(self):
        """
        Function that shows the current status (health, attack damage, etc) of the user's character
        """
        print("Health: " + str(self.health) + "   |   " +
              "Attack: " + str(self.attack) + "   |   " +
              "Double Damage: " + self.double_damage_percentage)

        print("Leeching: " + str(self.leeching) + "  |  " +
              "Defense: " + str(self.defense) + "    |  " +
              "Shield Bubble: " + str(self.shield_bubble))

        print("Ultimate Level Up Bar: " + str(self.ultimate_levelup_bar))
        print("Ultimate Level Up Bar Per Attack: " + str(self.ultimate_levelup_bar_per_attack))
        print("Level Up Bar: " + str(self.levelup_bar))

        print('')  # for spacing in the terminal

    @staticmethod
    def help_game():
        """
        Function about all the information that the player wants to know
        """
        #  Dictionary when the player chooses 'a' which is a help desk for commands
        commands = [
            'a = attack',
            'b = move',
            'c = status',
            'd = help',
            'e = quit'
        ]
        enemy = [
            'a = Deformed Mutating Human'
            'b = Mutated Human'
            'c = Lost Wanderer'
            'd = Chaser'

        ]

        type_print_effect("This is the help section. What do you want to know about?\n")

        #  Dictionary of information that the player can access
        help_dict = {
            'a': "Commands",
            'b': 'Enemies'}

        # dictionary for the user to see
        print(help_dict)

        # asks the user which topic do they need help with and lowercase for sanitation
        print('')
        player_chosen_help_command = input_print_effect('Which command do you want to choose? ').lower()

        # if statement to implement what the player has chosen from
        # a for the commands
        if player_chosen_help_command == 'a':
            print(commands)
            # space for terminal
            print('')
            # subset for the user to be asked what specific command they want to know plus lowercase for sanitation
            player_chosen_help_specific_command = input_print_effect('What command do you want to learn more? ').lower()
            print("-" * 20)

            # for attack
            if player_chosen_help_specific_command == 'a':
                print("Command for the player to attack.")
                print("Damage is based on the current weapon that the player is holding.")
                print('')

            # for move
            elif player_chosen_help_specific_command == 'b':
                print("Command for the player to move.")
                print("There is a small percentage that the player will encounter an enemy while moving.")
                print('')

            # for status
            elif player_chosen_help_specific_command == 'c':
                print("Command for the player to see their character's status.")
                print('')

            # for help section
            elif player_chosen_help_specific_command == 'd':
                print("Command for the player to see the help section of the game.")
                print('')

            # for quitting the game
            elif player_chosen_help_specific_command == 'e':
                print("Command for the player to quit the game.")
                print('')

            # when invalid input
            else:
                print('Invalid input. Please press the aproppriate letter.')
                print('')
                Player.help_game()

        # for enemies
        elif player_chosen_help_command == 'b':

            # for the user to see all types of enemies
            print(enemy)
            # space for terminal
            print('')
            # subset for the user to be asked what specific enemy they want to know plus lowercase for sanitation
            player_chosen_enemy_command = input_print_effect('What enemy do you want to learn more? ').lower()

            # for cleanliness in terminal
            print("-" * 20)

            # for deformed mutated human
            if player_chosen_enemy_command == 'a':
                print("Command for the player to attack.")
                print("Damage is based on the current weapon that the player is holding.")
                print('')

            # for mutated human
            elif player_chosen_enemy_command == 'b':
                print("A common enemy. Found at deserted land of the current planet")
                print("There is a small percentage that the player will encounter an enemy while moving.")
                print('')

            # for lost wanderer
            elif player_chosen_enemy_command == 'c':
                print("Command for the player to see their character's status.")
                print('')

            # for chaser
            elif player_chosen_enemy_command == 'd':
                print("Command for the player to see the help section of the game.")
                print('')
            elif player_chosen_enemy_command == 'e':
                print("Command for the player to quit the game.")
                print('')
            else:
                print('Invalid input. Please press the aproppriate letter.')

                # fencepost solution
                #  subset for the user to be asked what specific command they want to know plus
                #  lowercase for sanitation
                print('')
                Player.help_game()

        # use for cleaner terminal reading
        print("-" * 20)
        print('END OF HELP SECTION')
        print("-" * 20)
        print('')

    def quit_game(self):
        """
        Command that will quit the game when the player wants to
        """
        #  Asks the player if they want to quit for a second time to make sure it was not a mistake and lowercase
        # for sanitation
        ask_player_again = input_print_effect("Are you sure you want to exit? (Type y for yes, n for no) ").lower()

        while ask_player_again != '':
            if ask_player_again == 'y':
                type_print_effect(
                    'Thank you for playing my game! I hope you enjoyed my first ever Programming Project.')
                sys.exit()
            elif ask_player_again == 'n':
                print('')  # for spacing in the terminal
                Player.player_commands(self)

            else:
                type_print_effect("Invalid input\n")
                print('')  # for spacing in the terminal

                #  fencepost solution
                ask_player_again = input_print_effect(
                    "Are you sure you want to exit? (Type y for yes, n for no) ").lower()

    def player_commands(self):
        """
        All commands that the player can do when there are no enemies
        """
        print('What action do you want to do? We have the following.')

        #  for the user to see
        command_list = ["a = attack", 'b = move', 'c = status', 'd = help', 'e = quit']
        print(command_list)

        # asks player for the command that they want to do plus lowercase for sanitation
        player_actions = input("Please press the appropriate letter "
                               "for the command that you want to do. ").lower()
        print('')  # for spacing in the terminal

        if player_actions == 'a':
            type_print_effect('There are no enemies in sight...so far.')
        elif player_actions == 'b':
            Player.move(self)
        elif player_actions == 'c':
            Player.status(self)
        elif player_actions == 'd':
            Player.help_game()
        elif player_actions == 'e':
            Player.quit_game(self)
        else:
            type_print_effect("Invalid input.\n")
            print('')  # for spacing in the terminal
            Player.player_commands(self)

    def player_commands_attack_mode(self):
        """
        All commands that the player can do when the player encounters an enemy
        """
        print('What action do you want to do? We have the following.')

        #  for the user to see
        command_list = ["a = attack", 'b = flee', 'c = status', 'd = help', 'e = quit']
        print(command_list)

        # asks player for the command that they want to do plus lowercase for sanitation
        player_actions = input("Please press the appropriate letter "
                               "for the command that you want to do. ").lower()
        print('')  # for spacing in the terminal

        if player_actions == 'a':
            move = Player.attack(self)
        elif player_actions == 'b':
            move = Player.flee(self)
        elif player_actions == 'c':
            move = Player.status(self)
        elif player_actions == 'd':
            move = Player.help_game()
        elif player_actions == 'e':
            move = Player.quit_game(self)
        else:
            type_print_effect("Invalid input.\n")
            print('')  # for spacing in the terminal
            Player.player_commands_attack_mode(self)
        return move


# -----------------------
# No Need For Editing
# -----------------------


if __name__ == '__main__':
    main()
