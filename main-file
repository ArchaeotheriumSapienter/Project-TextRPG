"""
File: rpgameV3.py
----------------------------------------------------------------------
This is the main file. It contains the story of the game as well as the commands of the player


This is an RPG program where the player can fight various types of enemies. It has its own story line based
from the creator. The enemies also get harder as the player plays.

Milestone:
1. Prompt welcome message - done
2. Input Name - done
2. Finish introduction - done
3. Create character - done
4. Make character move, attack, defend - done
    a. make a set of moves that a player can do:
        - move done
        - attack - done
        - status - done
        - help - done
        - flee - done
        - leech - done
5. Make an enemy - done
6. Random occurence of enemy when player is walking - done
6. Make enemy fight the character - done
7. Do level up - done
8. Make a scripted enemy
9. continue storyline
"""
# character: for the players and enemies
# constants: for the various constants
# text_effect_and_exit_function: for effects

import random
from functions_and_classes import character, constants, text_effect_and_exit_function

# putting the effects into a variable for easier readability
type_print_effect = text_effect_and_exit_function.type_print_effect
input_print_effect = text_effect_and_exit_function.input_print_effect
text_delay_via_time_sleep = text_effect_and_exit_function.text_delay_via_time_sleep


# =========================================================
# MAIN FUNCTION
# =========================================================


def main():
    """
    Main function used to execute the whole program of the rpgameV3
    :return:
    """
    #  handler for the character parent class and the minimum value of each stats that a character can have
    p = character.Player()

    # name input to get the name of the player
    p.name = input_print_effect('Before we start, what is your name? ')

    # calling all of the common class enemy when the player walks with a one in third chance to encounter them
    # compiled into a dictionary for organization

    common_enemy_dict = {
        'deformed_mutated_human': character.DeformedMutatedHuman(),
        'mutated_human': character.MutatedHuman(),
        'lost_wanderer': character.LostWanderer(),
        'chaser': character.Chaser()
    }

    # welcome_message_and_introduction(p.name)

    # while loop to accomodate the half done program
    while True:
        #  p.level_up()
        # p.double_damage_and_damage_generator()
        p.player_commands(common_enemy_dict)

    # first_chapter()


# =========================================================
# FUNCTION FROM MAIN
# =========================================================


def welcome_message_and_introduction(user_name):
    """
    Welcome message for the user to see and asks the user whether to start the game or not
    Return: user_name
    """
    type_print_effect("Welcome to the Journey.\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect('You are an individual that suddenly woke up without any recollection.\n')
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect('Now you must understand what happened before you came to this place.\n')
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)

    # Asks the user for an input and the input of the user is turned into a lowercase to clean data
    start_game = input_print_effect('Type y to start or n to end the game ').lower()

    # If argument with the user's choices, if n, it will exit the program, anything other than y or n will
    # be taken as a sign to end the game, and y will prompt to start the introduction function
    while start_game != '':
        if start_game == 'y':
            # starts the game by going into the introduction
            introduction(user_name)

            # to prevent looping of the while loop after introduction
            break

        elif start_game == 'n':
            print('')  # space for terminal
            type_print_effect('Thank you for taking the time to check out my first Python Project.\n')
            text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
            type_print_effect('This means a lot to me. Have a great day! :)')

            # ends the code
            text_effect_and_exit_function.system_exit()

        else:
            print('')  # space for terminal
            print('Invalid input. Please press the appropriate letter.')

            # Fencepost solution
            start_game = input_print_effect('Type y to start or n to end the game ').lower()


# def first_chapter():


# =========================================================
# HELPER FUNCTIONS
# =========================================================

#  TODO: kulang pa dito YUNG WEAPONS LAGYAN MO MAMAYA
def introduction(user_name):
    """
    Opening dialogue with Alicia, the first character that the player saw, she will guide the player to the dojo
    Pre-condition: Player starts the game
    Post-condition: Player has a name and is headed for the dojo
    """
    print('')  # For spacing from the start menu
    type_print_effect("Hey, wake up! Are you okay? Who are you? And what are you doing near my home!\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("Oh my, you have so many bruises! Let me tend your wounds and then let's talk.\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("I'm Alicia by the way, its a good thing I found you here,\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("there isn't any hospitals or clinic here for hundreds of kilometers.\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("The best bet you have right now is me, good thing I have a first aid kit.\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("I forgot to even ask! What's your name?\n")

    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("That's a nice name, " + user_name + "\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("There we go, I patched your wounds. The problem now is where would you go?\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("And do you remember how you got here? Or who you are?\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("Hey! What's that in your shoulder, I guess I missed a wound.\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("You're one of them!!! I can't believe it. How did you wind up here? In the middle of nowhere?\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("You're here to defeat " + constants.BOSS_NAME + "\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("But you can't! You'll get yourself killed!\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("But if you're one of them, I guess you're destined towards that goal? Destiny is so weird\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("I mean, who gets to decide what you should do? Is it the player? I guess not...\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("The player is only looking at the screen right now, just watching our whole conversation.\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("Anyway, since I can see that you're one of them, I believe you can still remember how to "
                      "fight?\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("Or how to use your power? I want to see how you release your power!\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("Don't you rememeber anything? Come on, just one move!\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("Oh my, if that's the case, I think you should go to the nearby dojo.\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("The sensei there would help you remember the once you've lost\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("Before you go! I'll give you this to defend yourself.\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("You've acquired a KNIFE.\n")  # TODO: add weapons in the future
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("It's no longer safe ever since we've left Earth.\n")
    text_delay_via_time_sleep(constants.NEXT_TEXT_DURATION)
    type_print_effect("Goodluck out there " + user_name + "\n")


# =========================================================
# SUB-CLASS: PLAYER
# =========================================================

class Player(character.Character):
    """
    Subclass of Character and it has all the commands that the player can do
    """

    # initial stats of the player
    def __init__(self):
        super().__init__()

        # for the p.name instance to overwrite the values of the parent class
        self.name = ''
        self.health = 50
        self.health_max = 50
        self.attack = 15
        self.double_damage = 0.0
        self.leeching = 0
        self.defense = 7
        self.shield_bubble = 0
        self.shield_bubble_max = 0
        self.ultimate_levelup_bar = 20
        self.ultimate_levelup_bar_per_attack = 4
        self.levelup_bar = 0
        self.levelup_bar_max = 30
        self.levelup_per_defeated_enemy = 10

    def random_enemy_encounter(self, common_enemy_dict):
        """
        Function for random enemies to fight the player

        :param: common_enemy_dict - used to determine what enemy the player will fight
        """

        # each integer is equivalent to one type of enemy
        random_enemy = random.randint(1, constants.RANDOM_ENEMY_INTEGER)

        # the if statement messages are here for organization so that these messages should appear first
        # before the player commands attack mode
        if random_enemy == constants.DEFORMED_MUTATED_HUMAN:
            type_print_effect("A " + 'Deformed Mutated Human' + " has spotted you!\n")
            print('')  # space for terminal

        elif random_enemy == constants.MUTATED_HUMAN:
            type_print_effect("A " + 'Mutated Human' + " screeched as it notices your movement!\n")
            print('')  # space for terminal

        elif random_enemy == constants.LOST_WANDERER:
            type_print_effect("The sound of a " + 'Lost Wanderer' + " echoed through the wind. And it has "
                                                                    "caught your attention!\n")
            print('')  # space for terminal

        elif random_enemy == constants.CHASER:
            type_print_effect("A vicious " + 'Chaser' + " has smelled your scent. It suddenly sprinted "
                                                        "towards your direction!\n")
            print('')  # space for terminal

        # automatically goes to attack mode after encounter with an enemy
        self.player_commands_attack_mode(random_enemy, common_enemy_dict)

    def attack(self, random_enemy, common_enemy_dict):
        """
        Player attack using the .do_damage then if the player has leeching, call upon .leeching

        :parameter - random_enemy = for the function to see what enemy the player will face
        :parameter - common_enemy_dict = for the function to get the enemy attributes
        """

        # if statement stating what enemy the player will encounter
        if random_enemy == constants.DEFORMED_MUTATED_HUMAN:

            # lets the player attack first and .do_damage returns health to be analyzed here
            enemy_health = self.do_damage_with_shield_bubble(common_enemy_dict['deformed_mutated_human'])

            # if the enemy dies when their health is zero
            if enemy_health <= 0:
                # count the added level up points to the player by the levelup_bar
                self.levelup_bar = self.character_death(common_enemy_dict['deformed_mutated_human'])

                # lets the enemy revive themselves and player to level up themselves
                self.revive_enemy_and_level_them_up_alongside_player(common_enemy_dict, self.levelup_bar)

                # to cut the loop of still going into attack mode when the enemy dies
                self.player_commands(common_enemy_dict)

            # if enemy is not yet death it will prompt the enemy to do revenge attack
            else:
                # the enemy will do counter revenge
                self.enemy_attack(random_enemy, common_enemy_dict)

        # same formula from above, just with different enemies
        elif random_enemy == constants.MUTATED_HUMAN:
            enemy_health = self.do_damage_with_shield_bubble(common_enemy_dict['mutated_human'])
            if enemy_health <= 0:
                self.levelup_bar = self.character_death(common_enemy_dict['mutated_human'])
                self.revive_enemy_and_level_them_up_alongside_player(common_enemy_dict, self.levelup_bar)
                self.player_commands(common_enemy_dict)
            else:
                self.enemy_attack(random_enemy, common_enemy_dict)

        elif random_enemy == constants.LOST_WANDERER:
            enemy_health = self.do_damage_with_shield_bubble(common_enemy_dict['lost_wanderer'])
            if enemy_health <= 0:
                self.levelup_bar = self.character_death(common_enemy_dict['lost_wanderer'])
                self.revive_enemy_and_level_them_up_alongside_player(common_enemy_dict, self.levelup_bar)
                self.player_commands(common_enemy_dict)
            else:
                self.enemy_attack(random_enemy, common_enemy_dict)

        elif random_enemy == constants.CHASER:
            enemy_health = self.do_damage_with_shield_bubble(common_enemy_dict['chaser'])
            if enemy_health <= 0:
                self.levelup_bar = self.character_death(common_enemy_dict['chaser'])
                self.revive_enemy_and_level_them_up_alongside_player(common_enemy_dict, self.levelup_bar)
                self.player_commands(common_enemy_dict)
            else:
                self.enemy_attack(random_enemy, common_enemy_dict)

    def enemy_attack(self, random_enemy, common_enemy_dict):
        """
        Function that activates when the player chose flee in the commands but failed to escape,
        the enemy will attack the player first as a punishment.

        This also activates after the player attacks the enemy but the enemy is still alive, it does revenge attack
        :param random_enemy: to see what enemy will face the player
        :param common_enemy_dict: to let the function access the attributes of each enemy
        """

        # if statement stating what enemy the player will encounter
        if random_enemy == constants.DEFORMED_MUTATED_HUMAN:
            # the enemy will do counter revenge
            common_enemy_dict['deformed_mutated_human'].do_damage_with_shield_bubble(self)
            # if the player died from the damage, it will end the game with a message
            common_enemy_dict['deformed_mutated_human'].character_death(self)
            # if the player did not die, let the player choose their next command in attack mode
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        # same formula from above, just with different enemies
        elif random_enemy == constants.MUTATED_HUMAN:
            common_enemy_dict['mutated_human'].do_damage_with_shield_bubble(self)
            common_enemy_dict['mutated_human'].character_death(self)
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        elif random_enemy == constants.LOST_WANDERER:
            common_enemy_dict['lost_wanderer'].do_damage_with_shield_bubble(self)
            common_enemy_dict['lost_wanderer'].character_death(self)
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        elif random_enemy == constants.CHASER:
            common_enemy_dict['chaser'].do_damage_with_shield_bubble(self)
            common_enemy_dict['chaser'].character_death(self)
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)

    def revive_enemy_and_level_them_up_alongside_player(self, common_enemy_dict, levelup_bar):
        """
        This activates when the player defeats a common enemy. It lets all of the enemies level up all of their stats
        for a harder game in the long run. It also levels up the player

        :param - common_enemy_dict: to let the enemies level up with their respectful stats
        :param - levelup_bar: to check if the levelup_bar is the right digit for levelup_bar_max to activate
        level up
        """
        # if the levelup_bar reaches the max levelup_bar it will level up the player alongside the enemies

        #  if levelup_bar >= self.levelup_bar_max: #  TODO: utilize level up bar in the future
        # let the user level up
        self.level_up()

        # let all common enemies level up
        common_enemy_dict['deformed_mutated_human'].enemy_level_up()
        common_enemy_dict['mutated_human'].enemy_level_up()
        common_enemy_dict['lost_wanderer'].enemy_level_up()
        common_enemy_dict['chaser'].enemy_level_up()

    def move(self, common_enemy_dict):
        """
        Function when a player moves, uses random integer to determine the number of steps the player takes
        One out of an integer chance that the player will encounter an enemy while moving

        :param common_enemy_dict: used for the random enemy encounter
        """
        # probablity for enemy to show up while moving based on the constant
        enemy_possibility = random.randint(1, constants.ENEMY_POSSIBILITY)

        # how many steps the player can take
        number_of_moves = random.randint(1, constants.NUMBER_OF_MOVES)

        # if the player encounters an enemy
        if enemy_possibility == 1:
            # call upon the random_enemy_encounter to see what enemy the player will face off
            self.random_enemy_encounter(common_enemy_dict)
        elif enemy_possibility == 2:
            type_print_effect(self.name + " has nearly missed an enemy, and has moved " + str(number_of_moves)
                              + " steps.\n")
        elif enemy_possibility == 3:
            type_print_effect(self.name + " sneakily moved " + str(number_of_moves)
                              + " steps away from a monster.\n")
        else:
            type_print_effect(self.name + " has moved " + str(number_of_moves) + " steps.\n")

        print('')  # for spacing in the terminal

    def flee(self, random_enemy, common_enemy_dict):
        """
        A function only found while attack mode is one, a one in integer chance for the character to flee to prevent
        them from dying

        :param random_enemy: used if the flee failed, the particular enemy will attack
        :param common_enemy_dict: for the usage of the commands as well as the fighting of the enemy
        """
        flee_chance = random.randint(1, constants.FLEE_POSSIBILITY)

        if flee_chance == 1:
            type_print_effect("You successfully escaped the enemy!\n")
            print('')
            self.player_commands(common_enemy_dict)
        else:
            type_print_effect('You failed to escape.\n')
            self.enemy_attack(random_enemy, common_enemy_dict)

    def status(self, random_enemy, common_enemy_dict, who_called_me):
        """
        Function that shows the current status (health, attack damage, etc) of the user's character

        :param random_enemy: for the player_attack_mode
        :param common_enemy_dict: for the player_attack_mode
        :param who_called_me: to check if status will execute attack mode or passive mode commands
        """
        print("Health: " + str(self.health) + "   |   " +
              "Attack: " + str(self.attack) + "   |   " +
              "Double Damage: " + "{:.1%}".format(self.double_damage / 100))

        print("Leeching: " + str(self.leeching) + "  |   " +
              "Defense: " + str(self.defense) + "   |   " +
              "Shield Bubble: " + str(self.shield_bubble))

        # TODO: utilize these stats in the future
        # print("Ultimate Level Up Bar: " + str(self.ultimate_levelup_bar))
        # print("Ultimate Level Up Bar Per Attack: " + str(self.ultimate_levelup_bar_per_attack))
        # print("Level Up Bar: " + str(self.levelup_bar))
        print('')  # space for terminal

        # used when the player is in the middle of fighting a mob and chose status, it will go automatically to
        # attack mode to not let the player escape the loop
        if who_called_me == 'attack_mode':
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)
            print('')  # for spacing in the terminal

        print('')  # for spacing in the terminal

    # TODO: add player status
    def help_game(self, common_enemy_dict, random_enemy, who_called_me):
        """
        Function about all the information that the player wants to know

        :param common_enemy_dict: to determine the enemy stats as well as for the player_command and attack mode
        :param random_enemy: for the player command and attack mode
        :param who_called_me: for tjhe execution of attack mode or passive mode after utilizing the this function
        """
        # list for all the commands that the player can do
        commands = [
            'a = attack',
            'b = move',
            'c = status',
            'd = help',
            'e = quit',
            'f = flee'
        ]

        # to be used in the dictionary as grouping
        enemy = [
            'a = Common Enemies',
            'b = Uncommon Enemies',
            'c = Allies'
        ]

        common_enemy = [
            'a = Deformed Mutating Human',
            'b = Mutated Human',
            'c = Lost Wanderer',
            'd = Chaser'
        ]
        print("This is the help section. What do you want to know about?")
        print("Please press the appropriate letter of the information you want to know about.")
        print('')

        #  Dictionary of information that the player can access
        help_list = ["a = Commands", "b = Enemies"]

        # list for the user to see
        print(help_list)

        # asks the user which topic do they need help with and lowercase for sanitation
        print('')
        player_chosen_help_command = input_print_effect('Which criteria do you want to choose? ').lower()
        print('')

        # if statement to implement what the player has chosen from
        # a for the commands
        if player_chosen_help_command == 'a':
            print(commands)
            # space for terminal
            print('')
            # subset for the user to be asked what specific command they want to know plus lowercase for sanitation
            chosen_help_specific_command = input_print_effect('What command do you want to learn more? ').lower()

            # where the player will see all commands, below this code are just for looping through this function
            self.help_commands(chosen_help_specific_command, random_enemy, common_enemy_dict, who_called_me)

            # asked at the end of the submain commands section for the player to choose if they still want to know
            # more information on the commands subtopic or go back to the main topic
            print('')  # space terminal
            print(constants.COMMAND_END_HELP_BANNER)
            print('')  # space terminal

            # end statement for the user to see when they are inside the commands database
            type_print_effect("Do you want to dive further into knowing more about different commands?\n")
            type_print_effect("Or go back to the main help section?\n")
            type_print_effect("Press y to stick to commands and n for no.\n")
            type_print_effect("Or press b to go back to the main help section.\n")
            ask_commands_again = input_print_effect("Please press the appropriate letter. ").lower()
            print('')

            # while loop when the player is inside the command database for them to repeat over and over if they
            # like
            while True:
                # if they chose to learn more
                if ask_commands_again == 'y':
                    # shows the user the exact same thing earlier for them to choose what they want to learn more
                    # for the user to see all types of commands
                    print(commands)
                    # space for terminal
                    print('')
                    # subset for the user to be asked what specific command they want to know plus lowercase for
                    # sanitation
                    chosen_help_specific_command = input_print_effect(
                        'What command do you want to learn more? ').lower()

                    # where the player will see all commands, below this code are just for looping through this function
                    self.help_commands(chosen_help_specific_command, random_enemy, common_enemy_dict, who_called_me)

                    # asked at the end of the submain enemies section for the player to choose if they still want to
                    # know more information on the enemies subtopic or go back to the main topic
                    print('')  # space terminal
                    print(constants.COMMAND_END_HELP_BANNER)
                    print('')  # space terminal

                    # end statement for the user to see when they are inside the enemy database
                    type_print_effect("Press y to stick to commands and n for no.\n")
                    type_print_effect("Or press b to go back to the main help section.\n")
                    ask_commands_again = input_print_effect("Please press the appropriate letter. ").lower()
                    print('')

                # when the player choses no
                elif ask_commands_again == 'n':
                    # to end the help loop and let the player choose another command besides help

                    # used when the player is in the middle of fighting a mob and chose help,
                    # it will go automatically to
                    # attack mode to not let the player escape the loop
                    if who_called_me == 'attack_mode':
                        self.player_commands_attack_mode(random_enemy, common_enemy_dict)
                        print('')  # for spacing in the terminal
                    else:
                        self.player_commands(common_enemy_dict)

                # when the player wants to go back to the main section
                elif ask_commands_again == 'b':
                    self.help_game(common_enemy_dict, random_enemy, who_called_me)

                else:
                    # fencepost solution
                    type_print_effect("Invalid input. Please press the appropriate letter.\n")
                    print('')  # space terminal
                    type_print_effect("Press y to stick to commands and n for no.\n")
                    type_print_effect("Or press b to go back to the main help section.\n")
                    ask_commands_again = input_print_effect("Please press the appropriate letter. ").lower()
                    print('')

        # for when the player chooses enemies in the main help section
        elif player_chosen_help_command == 'b':
            # for the user to see all types of enemies
            print(enemy)
            # space for terminal
            print('')
            # subset for the user to be asked what specific enemy they want to know plus lowercase for sanitation
            chosen_enemy_help = input_print_effect('What enemy do you want to learn more? ').lower()
            print('')  # space for terminal

            # where the player will see the enemies, below this code are just for looping through this function
            self.help_enemies(chosen_enemy_help, common_enemy, random_enemy, common_enemy_dict, who_called_me)

            # asked at the end of the submain enemies section for the player to choose if they still want to know
            # more information on the enemies subtopic or go back to the main topic
            print('')  # space terminal
            print(constants.ENEMY_END_HELP_SECTION)
            print('')  # space terminal

            # end statement for the user to see when they are inside the enemy database
            type_print_effect("Do you want to dive further into knowing more about different enemies?\n")
            type_print_effect("Or go back to the main help section?\n")
            type_print_effect("Press y to stick to enemies and n for no.\n")
            type_print_effect("Or press b to go back to the main help section.\n")
            ask_enemies_again = input_print_effect("Please press the appropriate letter. ").lower()
            print('')

            # while loop when the player is inside the enemy database for them to repeat over and over if they
            # like
            while True:
                # if they chose to learn more
                if ask_enemies_again == 'y':
                    # shows the user the exact same thing earlier for them to choose what they want to learn more
                    # for the user to see all types of enemies
                    print(enemy)
                    print('')  # space for terminal
                    chosen_enemy_help = input_print_effect('What enemy do you want to learn more? ').lower()
                    print('')  # space for terminal

                    # chosen enemy help will go inside prompting a new if statement to be executed inside help_enemies
                    self.help_enemies(chosen_enemy_help, common_enemy, random_enemy, common_enemy_dict, who_called_me)

                    print('')  # space terminal
                    print(constants.ENEMY_END_HELP_SECTION)
                    print('')  # space terminal

                    # asks the user again if they still want to stick
                    type_print_effect("Press y to stick to enemies and n for no.\n")
                    type_print_effect("Or press b to go back to the main help section.\n")
                    ask_enemies_again = input_print_effect("Please press the appropriate letter. ").lower()
                    print('')

                # when the player choses no
                elif ask_enemies_again == 'n':
                    # to end the help loop and let the player choose another command besides help

                    # used when the player is in the middle of fighting a mob and chose help,
                    # it will go automatically to
                    # attack mode to not let the player escape the loop
                    if who_called_me == 'attack_mode':
                        self.player_commands_attack_mode(random_enemy, common_enemy_dict)
                        print('')  # for spacing in the terminal
                    else:
                        self.player_commands(common_enemy_dict)

                # when the player wants to go back to the main section
                elif ask_enemies_again == 'b':
                    self.help_game(common_enemy_dict, random_enemy, who_called_me)

                else:
                    # fencepost solution
                    type_print_effect("Invalid input. Please press the appropriate letter.\n")
                    print('')  # space terminal
                    type_print_effect("Press y to stick to enemies and n for no.\n")
                    type_print_effect("Or press b to go back to the main help section.\n")
                    ask_enemies_again = input_print_effect("Please press the appropriate letter. ").lower()
                    print('')

        # use for cleaner terminal reading at the end of each information given
        print('')  # space terminal
        print(constants.HELP_END_BANNER)
        print('')  # space terminal

    def help_commands(self, chosen_help_specific_command, random_enemy, common_enemy_dict, who_called_me):
        """
        Functions particular for the commands. used to determine what the commands do

        :param chosen_help_specific_command: to execute particular command chosen by the player
        :param random_enemy: for the player commands and attack mode
        :param common_enemy_dict: for the player commands and attack mode
        :param who_called_me: to determine if it will go to passive or attack mode after this function
        """
        # for attack
        if chosen_help_specific_command == 'a':
            print('')  # space terminal
            print(constants.COMMAND_DESCRIPTION_HELP_BANNER)
            print('')  # space terminal
            print("Command for the player to attack.")
            print("Damage is based on the current weapon that the player is holding.")

        # for move
        elif chosen_help_specific_command == 'b':
            print('')  # space terminal
            print(constants.COMMAND_DESCRIPTION_HELP_BANNER)
            print('')  # space terminal
            print("Command for the player to move.")
            print("There is a small percentage that the player will encounter an enemy while moving.")

        # for status
        elif chosen_help_specific_command == 'c':
            print('')  # space terminal
            print(constants.COMMAND_DESCRIPTION_HELP_BANNER)
            print('')  # space terminal
            print("Command for the player to see their character's status.")

        # for help section
        elif chosen_help_specific_command == 'd':
            print('')  # space terminal
            print(constants.COMMAND_DESCRIPTION_HELP_BANNER)
            print('')  # space terminal
            print("Command for the player to see the help section of the game.")

        # for quitting the game
        elif chosen_help_specific_command == 'e':
            print('')  # space terminal
            print(constants.COMMAND_DESCRIPTION_HELP_BANNER)
            print('')  # space terminal
            print("Command for the player to quit the game.")

        # for fleeing
        elif chosen_help_specific_command == 'f':
            print('')  # space terminal
            print(constants.COMMAND_DESCRIPTION_HELP_BANNER)
            print('')  # space terminal
            print("Only available when an enemy has approached the player.")
            print('There is a percentage that the flee will be successful, if it fails the enemy')
            print('will attack the player for that turn.')

        # when invalid input
        else:
            print('Invalid input. Please press the aproppriate letter.')
            print('')
            self.help_game(common_enemy_dict, random_enemy, who_called_me)

    def help_enemies(self, chosen_enemy_help, common_enemy, random_enemy, common_enemy_dict, who_called_me):
        """
        Sub function of help that has the information for all the enemies so the help function is not overcrowded
        with lines of code

        :param chosen_enemy_help: to execute particular enemy information chosen by the player
        :param common_enemy: to check the particular common enemy that the player wants to know
        :param random_enemy: for the player commands and attack mode
        :param common_enemy_dict: for the player commands and attack mode
        :param who_called_me: to determine if it will go to passive or attack mode after this function
        """
        # for the common enemies
        if chosen_enemy_help == 'a':
            # for the user to see all common enemies possible
            print(common_enemy)
            # space for terminal
            print('')
            # subset for the user to be asked what specific common enemy they want to know plus lowercase for
            # sanitation
            chosen_common_enemy_help = input_print_effect('What enemy do you want '
                                                          'to learn more? ').lower()
            print('')  # space for terminal

            # neverending loop if they want to keep finding out about enemies
            while True:
                # for deformed mutated human
                if chosen_common_enemy_help == 'a':
                    # Used for aesthetics in the terminal
                    print(constants.ENEMY_STATS_BANNER)
                    print('')
                    # for gap for the player to see the stats for a while before the backstory
                    text_effect_and_exit_function.text_delay_via_time_sleep(constants.HELP_BACKSTORY_NEXT_TEXT)
                    # prints the stats first
                    print("Health: " + str(common_enemy_dict['deformed_mutated_human'].health) + "    |   " +
                          "Attack: " + str(common_enemy_dict['deformed_mutated_human'].attack) + "   |   " +
                          "Double Damage: "
                          + "{:.1%}".format(common_enemy_dict['deformed_mutated_human'].double_damage / 100))

                    print("Leeching: " + str(common_enemy_dict['deformed_mutated_human'].leeching) + "  |   " +
                          "Defense: " + str(common_enemy_dict['deformed_mutated_human'].defense) + "   |   " +
                          "Shield Bubble: " + str(common_enemy_dict['deformed_mutated_human'].shield_bubble))

                    # then prints the backstory
                    # plus cleanliness in the terminal
                    print('')
                    print(constants.ENEMY_BACK_STORY_BANNER)
                    print('')
                    type_print_effect("Once a human that came from Earth, this "
                                      "abomination is the result of countless\n")
                    type_print_effect("experiments that failed, leaving him a husk of his former self.\n")
                    type_print_effect("They no longer have any sort of consciousness. "
                                      "Instead, what's left is their pure\n")
                    type_print_effect('rage for what has become of them. They have lower '
                                      'health due to them being the \n')
                    type_print_effect('later stage in decomposition than the Mutated Human. '
                                      'However, they make up for it\n')
                    type_print_effect('by their sheer strength.\n')
                    type_print_effect('')
                    break  # to break the while loop

                # for mutated human
                elif chosen_common_enemy_help == 'b':
                    # Used for aesthetics in the terminal
                    print(constants.ENEMY_STATS_BANNER)
                    print('')
                    # for gap for the player to see the stats for a while before the backstory
                    text_effect_and_exit_function.text_delay_via_time_sleep(constants.HELP_BACKSTORY_NEXT_TEXT)
                    print("Health: " + str(common_enemy_dict['mutated_human'].health) + "    |   " +
                          "Attack: " + str(common_enemy_dict['mutated_human'].attack) + "   |   " +
                          "Double Damage: " + "{:.1%}".format(common_enemy_dict['mutated_human'].double_damage / 100))

                    print("Leeching: " + str(common_enemy_dict['mutated_human'].leeching) + "  |   " +
                          "Defense: " + str(common_enemy_dict['mutated_human'].defense) + "   |   " +
                          "Shield Bubble: " + str(common_enemy_dict['mutated_human'].shield_bubble))

                    # then prints the backstory
                    # plus cleanliness in the terminal
                    print('')
                    print(constants.ENEMY_BACK_STORY_BANNER)
                    print('')
                    type_print_effect("It has the same sad fate as the Deformed Mutated Human.\n")
                    type_print_effect("The difference, however, is that the Mutated Human is a failed experiment,\n")
                    type_print_effect("that has been conducted quite recently. They have a small percentage\n")
                    type_print_effect('of their consciousness still intact, therefore making their suffering more\n')
                    type_print_effect('horrendous. They have higher health than the Deformed Mutated Human due to\n')
                    type_print_effect('them being recent test subjects. However, they have a higher defense than the\n')
                    type_print_effect('Deformed Mutated Human due to their intact body composition.\n')
                    type_print_effect('')
                    break  # to break the while loop

                # for lost wanderer
                elif chosen_common_enemy_help == 'c':
                    # Used for aesthetics in the terminal
                    print(constants.ENEMY_STATS_BANNER)
                    print('')
                    # for gap for the player to see the stats for a while before the backstory
                    text_effect_and_exit_function.text_delay_via_time_sleep(constants.HELP_BACKSTORY_NEXT_TEXT)
                    print("Health: " + str(common_enemy_dict['lost_wanderer'].health) + "    |   " +
                          "Attack: " + str(common_enemy_dict['lost_wanderer'].attack) + "   |   " +
                          "Double Damage: " + "{:.1%}".format(common_enemy_dict['lost_wanderer'].double_damage / 100))

                    print("Leeching: " + str(common_enemy_dict['lost_wanderer'].leeching) + "  |   " +
                          "Defense: " + str(common_enemy_dict['lost_wanderer'].defense) + "   |   " +
                          "Shield Bubble: " + str(common_enemy_dict['lost_wanderer'].shield_bubble))

                    # then prints the backstory
                    # plus cleanliness in the terminal
                    # TODO: add the history about the incident in the main story line that caused lost
                    #  wanderers to escape the experiments
                    print('')
                    print(constants.ENEMY_BACK_STORY_BANNER)
                    print('')
                    type_print_effect("These are individuals that have escaped the experiments but have failed to\n")
                    type_print_effect("mitigate the effects, therefore making their body worse than the Deformed\n")
                    type_print_effect("and Mutated Humans. They have drastically low health due to the effects but\n")
                    type_print_effect('they have gained the ability to restore their health '
                                      'when attacking individuals.\n')
                    type_print_effect('Unlike the Mutated Humans the Lost Wanderers have lost their\n')
                    type_print_effect('consciousness due to them escaping a long time ago after the incident.\n')
                    type_print_effect('')
                    break  # to break the while loop

                # for chaser
                elif chosen_common_enemy_help == 'd':
                    # Used for aesthetics in the terminal
                    print(constants.ENEMY_STATS_BANNER)
                    print('')
                    # for gap for the player to see the stats for a while before the backstory
                    text_effect_and_exit_function.text_delay_via_time_sleep(constants.HELP_BACKSTORY_NEXT_TEXT)
                    print("Health: " + str(common_enemy_dict['chaser'].health) + "    |   " +
                          "Attack: " + str(common_enemy_dict['chaser'].attack) + "   |   " +
                          "Double Damage: " + "{:.1%}".format(common_enemy_dict['chaser'].double_damage / 100))

                    print("Leeching: " + str(common_enemy_dict['chaser'].leeching) + "  |   " +
                          "Defense: " + str(common_enemy_dict['chaser'].defense) + "   |   " +
                          "Shield Bubble: " + str(common_enemy_dict['chaser'].shield_bubble))

                    # then prints the backstory
                    # plus cleanliness in the terminal
                    print('')
                    print(constants.ENEMY_BACK_STORY_BANNER)
                    print('')
                    type_print_effect("These are animals of different origins that have escaped the experiments.\n")
                    type_print_effect(
                        "They are similar to the lost wanderers. Their entire existence is solely based\n")
                    type_print_effect(" in finding nutrition to feed themselves as they decay faster than the\n")
                    type_print_effect('Deformed and Mutated Humans. Out of all the enemies that the player encounter\n')
                    type_print_effect('while walking, they have the most balanced stats and have also gained the\n')
                    type_print_effect('the leech ability as well as high defense from their tough exterior.\n')
                    type_print_effect('')
                    break  # to break the while loop

                else:
                    print('Invalid input. Please press the aproppriate letter.')
                    print('')

                    print(common_enemy)
                    # space for terminal
                    print('')
                    # subset for the user to be asked what specific common enemy they want to know plus lowercase for
                    # sanitation
                    chosen_common_enemy_help = input_print_effect('What enemy do you want '
                                                                  'to learn more? ').lower()
                    print('')  # space for terminal

        # TODO: add uncommon enemies and allies later
        elif chosen_enemy_help == 'b' or chosen_enemy_help == 'c':
            print('Coming Soon!')

        else:  #
            print('Invalid input. Please press the appropriate letter.')
            print('')
            self.help_game(common_enemy_dict, random_enemy, who_called_me)

    def quit_game(self, common_enemy_dict, random_enemy, who_called_me='attack_mode'):
        """
        Command that will quit the game when the player wants to

        :param common_enemy_dict: for the player commands or attack mode
        :param random_enemy: for the player command or attack mode
        :param who_called_me: used to determine if it will go to passive or attack mode after this function
        """

        #  Asks the player if they want to quit for a second time to make sure it was not a mistake and lowercase
        # for sanitation
        ask_player_again = input_print_effect("Are you sure you want to exit? (Type y for yes, n for no) ").lower()

        while ask_player_again != '':
            if ask_player_again == 'y':
                type_print_effect(
                    'Thank you for playing my game! I hope you enjoyed my first ever Programming Project.')
                text_effect_and_exit_function.system_exit()
            elif ask_player_again == 'n':
                # TODO: BUG HELP
                print('')  # for spacing in the terminal
                # used when the player is in the middle of fighting a mob and chose quit, it will go automatically to
                # attack mode to not let the player escape the loop
                if who_called_me == 'attack_mode':
                    self.player_commands_attack_mode(random_enemy, common_enemy_dict)
                    print('')  # for spacing in the terminal

                #  to prevent endless loop
                else:
                    self.player_commands(common_enemy_dict)

            else:
                type_print_effect("Invalid input\n")
                print('')  # for spacing in the terminal

                #  fencepost solution
                ask_player_again = input_print_effect(
                    "Are you sure you want to exit? (Type y for yes, n for no) ").lower()

    def player_commands(self, common_enemy_dict):
        """
        All commands that the player can do when there are no enemies

        :param common_enemy_dict: used for the random enemy encounter as well as the stats of the enemies in help.
        """
        print('What action do you want to do? We have the following.')

        #  for the user to see
        command_list = ["a = attack", 'b = move', 'c = status', 'd = help', 'e = quit']
        print(command_list)

        # asks player for the command that they want to do plus lowercase for sanitation
        player_actions = input("Please press the appropriate letter "
                               "for the command that you want to do. ").lower()
        print('')  # for spacing in the terminal

        # for attack
        if player_actions == 'a':
            # player can't fight anybody in player_command mode, has to be in attack mode
            type_print_effect('There are no enemies in sight...so far.\n')
            # bug fix, to not let the player go into attack mode after the print statement above
            print('')  # for terminal
            self.player_commands(common_enemy_dict)

        # for move
        elif player_actions == 'b':
            self.move(common_enemy_dict)

        # for status
        elif player_actions == 'c':
            # to differentiate player_command_attack_mode from the normal player_command
            # calls None for positional arguments because in passive mode there are no random enemies
            self.status(random_enemy=None, common_enemy_dict=None, who_called_me='passive_mode')

        # for help
        elif player_actions == 'd':
            # same idea with status
            self.help_game(common_enemy_dict, random_enemy=None, who_called_me='passive_mode')

        # for quit
        elif player_actions == 'e':
            # as well as this one
            self.quit_game(common_enemy_dict, random_enemy=None, who_called_me='passive_mode')
        else:
            type_print_effect("Invalid input.\n")
            print('')  # for spacing in the terminal
            self.player_commands(common_enemy_dict)

    def player_commands_attack_mode(self, random_enemy, common_enemy_dict):
        """
        All commands that the player can do when the player encounters an enemy

        :param random_enemy: used to determine the specific enemy that the player will attack when they encounter one
        in random enemy encounter
        :param common_enemy_dict: used for the classes of the enemy for the enemy to attack and other commands
        """
        print('What action do you want to do? We have the following.')

        #  for the user to see
        command_list = ["a = attack", 'b = FLEE', 'c = status', 'd = help', 'e = quit']
        print(command_list)

        # asks player for the command that they want to do plus lowercase for sanitation
        player_actions = input("Please press the appropriate letter "
                               "for the command that you want to do. ").lower()

        print('')  # for spacing in the terminal

        # for attack
        if player_actions == 'a':
            Player.attack(self, random_enemy, common_enemy_dict)

        # for flee
        elif player_actions == 'b':
            # an updated command that the player can do ONLY if they are in attack mode.
            # possibility for the player to run away
            self.flee(random_enemy, common_enemy_dict)

        # for status
        elif player_actions == 'c':
            # to differentiate player_command_attack_mode from the normal player command
            self.status(random_enemy, common_enemy_dict, who_called_me='attack_mode')

        # for help
        elif player_actions == 'd':
            self.help_game(common_enemy_dict, random_enemy, who_called_me='attack_mode')

        # for quit
        elif player_actions == 'e':
            self.quit_game(common_enemy_dict, random_enemy, who_called_me='attack_mode')
        else:
            type_print_effect("Invalid input.\n")
            print('')  # for spacing in the terminal
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)


# =========================================================
# NO NEED FOR EDITING
# =========================================================


if __name__ == '__main__':
    main()
