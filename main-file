"""
File: rpgame.py
----------------------------------------------------------------------
This is an RPG program where the player can fight various types of enemies. It has its own story line based
from the creator. The enemies also get harder as the player plays.

Milestone:
1. Prompt welcome message - done
2. Input Name - done
2. Finish introduction - done
3. Create character - done
4. Make character move, attack, defend - done
    a. make a set of moves that a player can do:
        - move done
        - attack - done
        - status - done
        - help - done
        - flee - done
        - leech - almost
5. Make an enemy - done
6. Random occurence of enemy when player is walking - done
6. Make enemy fight the character - done
8. Make a scripted enemy
9. continue storyline
"""

import random  # used for moving and random events in the game
import sys  # used for the text effect
import time  # used to delay the texts for a few miliseconds

BOSS_NAME = '⊑⟒⍀?'
# TODO: Change the constants later after debugging: enemy possibility, random enemy integer, break defense chance, flee
# ======================= POSSIBILITY CONSTANTS ======================= #
ENEMY_POSSIBILITY = 1  # constant for random_enemy_occurance based from 1 to an integer for the possibility of an enemy
# spawning
FLEE_POSSIBILITY = 2  # constant for flee function based from 1 to an integer for the possibility of the character
# fleeing
RANDOM_ENEMY_INTEGER = 1  # used for debugging in the random_enemy_occurance. Each integer
NUMBER_OF_MOVES = 10  # used to determine the number of steps possible for the player to do
BREAK_DEFENSE_CHANCE = 1  # constant used in the .do_damage function in which there is a one in an integer possibility
# that an attack can break a defense

# ======================= RANDOM ENEMY CONSTANTS ======================= #
# constants used for the random enemy function
DEFORMED_MUTATED_HUMAN = 1  # dedicated number for the monster deformed mutated human
MUTATED_HUMAN = 2  # dedicated number for the monster mutated human
LOST_WANDERER = 3  # dedicated number for the lost wanderer
CHASER = 4  # dedicated number for the chaser

# ======================= TEXT EFFECT CONSTANTS ======================= #
NEXT_TEXT_DURATION = 0.1  # constant used for having a gap in between text that have the typing effect
INPUT_AND_TEXT_EFFECT_DURATION = 0.001  # 0.05 normal speed

# ========================= AESTHETIC CONSTANTS ======================= #
NUMBER_OF_DASHES = 25  # used for the breakers found in the terminal when the user plays
HELP_BACKSTORY_NEXT_TEXT = 0.2  # similar with NEXT_TEXT_DURATION difference however is this is used
# Used when the player attacks
PLAYER_TURN_BANNER = '=' * NUMBER_OF_DASHES + " PLAYER'S TURN " + '=' * NUMBER_OF_DASHES
ENEMY_TURN_BANNER = '=' * NUMBER_OF_DASHES + " ENEMY'S TURN " + '=' * NUMBER_OF_DASHES

# for the help section after the stats of the enemy have been revealed


# =========================================================
# MAIN FUNCTION
# =========================================================


def main():
    # values in the classes are (from left to right):
    # name, health, health_max, attack, double_damage, leeching, defense, shield_bubble,
    # ultimate_levelup_bar, ultimate_levelup_bar_per_attack, levelup_bar, levelup_per_defeated_enemy

    #  handler for the character parent class and the minimum value of each stats that a character can have
    p = Player()

    # name input to get the name of the player
    p.name = input_print_effect('Before we start, what is your name? ')

    # calling all of the common class enemy when the player walks with a one in third chance to encounter them
    # compiled into a dictionary for organization

    common_enemy_dict = {
        'deformed_mutated_human': DeformedMutatedHuman(),
        'mutated_human': MutatedHuman(),
        'lost_wanderer': LostWanderer(),
        'chaser': Chaser()
    }

    # welcome_message_and_introduction(p.name)
    debug_attack = input('Just Press Enter ')

    while debug_attack == '':
        p.player_commands(common_enemy_dict)
        debug_attack = input('Just Press Enter  ')

    # first_chapter()


# =========================================================
# FUNCTION FROM MAIN
# =========================================================


def welcome_message_and_introduction(user_name):
    """
    Welcome message for the user to see and asks the user whether to start the game or not
    Return: user_name
    """
    type_print_effect("Welcome to the Journey.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect('You are an individual that suddenly woke up without any recollection.\n')
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect('Now you must understand what happened before you came to this place.\n')
    time.sleep(NEXT_TEXT_DURATION)

    # Asks the user for an input and the input of the user is turned into a lowercase to clean data
    start_game = input_print_effect('Type y to start or n to end the game ').lower()

    # If argument with the user's choices, if n, it will exit the program, anything other than y or n will
    # be taken as a sign to end the game, and y will prompt to start the introduction function
    while start_game != '':
        if start_game == 'y':
            introduction(user_name)
            break
        elif start_game == 'n':
            print('')  # space for terminal
            type_print_effect('Thank you for taking the time to check out my first Python Project.\n')
            time.sleep(NEXT_TEXT_DURATION)
            type_print_effect('This means a lot to me. Have a great day! :)')
            sys.exit()
        else:
            print('')  # space for terminal
            print('Invalid input. Please press the appropriate letter.')

            # Fencepost solution
            start_game = input_print_effect('Type y to start or n to end the game ').lower()


# def first_chapter():


# =========================================================
# HELPER FUNCTIONS
# =========================================================

#  TODO: kulang pa dito YUNG WEAPONS LAGYAN MO MAMAYA
def introduction(user_name):
    """
    Opening dialogue with Alicia, the first character that the player saw, she will guide the player to the dojo
    Pre-condition: Player starts the game
    Post-condition: Player has a name and is headed for the dojo
    """
    print('')  # For spacing from the start menu
    type_print_effect("Hey, wake up! Are you okay? Who are you? And what are you doing near my home!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Oh my, you have so many bruises! Let me tend your wounds and then let's talk.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("I'm Alicia by the way, its a good thing I found you here,\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("there isn't any hospitals or clinic here for hundreds of kilometers.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("The best bet you have right now is me, good thing I have a first aid kit.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("I forgot to even ask! What's your name?\n")

    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("That's a nice name, " + user_name + "\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("There we go, I patched your wounds. The problem now is where would you go?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("And do you remember how you got here? Or who you are?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Hey! What's that in your shoulder, I guess I missed a wound.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("You're one of them!!! I can't believe it. How did you wind up here? In the middle of nowhere?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("You're here to defeat " + BOSS_NAME + "\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("But you can't! You'll get yourself killed!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("But if you're one of them, I guess you're destined towards that goal? Destiny is so weird\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("I mean, who gets to decide what you should do? Is it the player? I guess not...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("The player is only looking at the screen right now, just watching our whole conversation.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Anyway, since I can see that you're one of them, I believe you can still remember how to "
                      "fight?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Or how to use your power? I want to see how you release your power!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Don't you rememeber anything? Come on, just one move!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Oh my, if that's the case, I think you should go to the nearby dojo.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("The sensei there would help you remember the once you've lost\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Before you go! I'll give you this to defend yourself.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("It's no longer safe ever since we've left Earth.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Goodluck out there " + user_name + "\n")


# =========================================================
# SUB-HELPER FUNCTIONS
# =========================================================

def type_print_effect(text):
    """
    This function takes print strings and change them to have a typing effect with the help of time
    sleep so that it has a delay, much like when someone is typing

    Parameter: text - the inputted text where it would be converted to a typing effect
    """

    for character in text:
        print(character, end='')
        sys.stdout.flush()
        time.sleep(INPUT_AND_TEXT_EFFECT_DURATION)


def input_print_effect(text):
    """
    This function is the same with text_print_effect, the difference is that this is used
    when a user inputs something and a message is prompted

    :param: text - the message with the input from the user
    :return: value - the answer that the user gave to be used by other functions
    """
    for character in text:
        print(character, end='')
        sys.stdout.flush()
        time.sleep(INPUT_AND_TEXT_EFFECT_DURATION)
    value = input()
    return value


# =========================================================
# PARENT CLASS
# =========================================================


class Character:
    """
    Parent Class for all of the stats of each character, as well as the player.
    This also has all the functions that each character can do
    """

    def __init__(self):
        self.name = ''
        self.health = 1
        self.health_max = 1
        self.attack = 10
        self.double_damage = 0
        self.leeching = 0
        self.defense = 0
        self.shield_bubble = 0
        self.shield_bubble_max = 0

        # stats for levelling up to gain your ultimate
        self.ultimate_levelup_bar = 0
        self.ultimate_levelup_bar_per_attack = 0

        # stats for levelling up your character
        self.levelup_bar = 0
        self.levelup_per_defeated_enemy = 0

        #  double damage converted to percentage for the user to see in the status command
        self.double_damage_percentage = "{0:.2%}".format(self.double_damage)

    def do_damage_with_shield_bubble(self, enemy):
        """
        Function for when the player or enemy attacks, parent function of do_damage_player and do_damage_enemy.
        It first computes the shield bubble of the characters then if the shield bubble pops it will commence to
        the normal kinds of attacks with defense
        :param enemy: To lower the health of the enemy
        :return enemy.health: To be analyzed inside the attack function in an if statement
        """
        # damage of the character
        damage = random.randint(0, self.attack)
        print('DEBUGGING: DAMAGE IS ', damage, "OF", self.name)

        # computes the shield bubble of the enemy to the damage done by the character
        enemy.shield_bubble = enemy.shield_bubble - damage
        print("DEBUGGING: THE SHIELD BUBBLE OF " + enemy.name + " IS " + str(enemy.shield_bubble))

        if enemy.shield_bubble <= 0:
            print('DEBUGGING: MY SHIELD BUBBLE BROKE OH NO WTF IS THISSSSSSS')
            self.do_damage(enemy, damage)

        else:
            if self.__class__ == Player:
                # for aesthetics purposes
                print(PLAYER_TURN_BANNER)
            else:
                print(ENEMY_TURN_BANNER)
                # for aesthetics purposes
            type_print_effect(enemy.name + " 's Shield Bubble has withstand the attack of " + self.name + ".\n")
            type_print_effect("The remaining Shield Bubble of " + enemy.name + " is "
                              + str(enemy.shield_bubble) + ".\n")
            print('')  # for terminal

        # returns enemy health to be analyzed in an if statement inside the caller in attack function
        return enemy.health

    def do_damage(self, enemy, damage):
        """
        Function when the shield bubble burst, it will attack the health directly
        :param enemy: to determine which will give damage to
        :param damage: amount of damage that will be given
        :return enemy_health: to be analyzed in an if statement in the attack function in the Player class
        """
        # utilizing the defense, one in three chance that the defense will break
        break_defense_chance = random.randint(1, BREAK_DEFENSE_CHANCE)

        # checks to see if the class that called the method is the player
        if self.__class__ == Player:
            # when the player does damage to the enemy, has messages for the terminal
            self.do_damage_player(enemy, damage, break_defense_chance)

        # if the caller are the common enemies
        elif self.__class__ == DeformedMutatedHuman or self.__class__ == MutatedHuman \
                or self.__class__ == LostWanderer or self.__class__ == Chaser:

            # when the enemy attacks, gives messages whether the player died and how many damage the enemy dealt
            self.do_damage_enemy(enemy, damage, break_defense_chance)

        # returns enemy health to be analyzed in an if statement inside the caller in attack function
        return enemy.health

    def do_damage_player(self, enemy, damage, break_defense_chance):
        """
        Subfunction of the do_damage, for cutting down code inside the do_damage function.
        This function gives the messages of damage to the user as the player
        :param enemy: for the enemy to lose health and give name in terminal
        :param damage: to determine damage given to the enemy
        :param break_defense_chance: to determine if the enemy will break its defense
        :return: self.health: so that it will check whether or not the enemy or player will die
        """

        # for aesthetics in terminal
        print(PLAYER_TURN_BANNER)
        # if the defenses break
        if break_defense_chance == 1:
            # when the damage is equals to zero
            if damage == 0:
                type_print_effect(enemy.name + " felt a scratch! " +
                                  self.name + " dealt " + str(damage) + " damage!\n")

            else:
                # enemy losses health with no defense
                enemy.health = enemy.health - damage
                type_print_effect(enemy.name + "'s defense has broken! " +
                                  self.name + " dealt " + str(damage) + " damage!\n")
                type_print_effect("The " + enemy.name + "'s remaining health is " +
                                  str(enemy.health) + "!\n")
                # call upon leeching when there is damage from the enemy
                if self.leeching != 0 and self.health < self.health_max:
                    self.health = self.leeching_health(damage, enemy)

        # if it does not break
        else:
            # if the damage is lower than the defense of the enemy
            if damage <= enemy.defense:
                type_print_effect(enemy.name + " has defended all of your attack!\n")
                type_print_effect("The " + enemy.name + "'s remaining health is " +
                                  str(enemy.health) + "!\n")

            # if the damage exceeds the defense
            else:
                # used when the damage is larger than the defense
                damage_with_defense = damage - enemy.defense

                enemy.health = enemy.health - damage_with_defense

                type_print_effect(enemy.name + " defended a part of " + self.name + " attack!\n")
                type_print_effect(self.name + " dealt " + str(damage) + " damage!\n")
                type_print_effect("The " + enemy.name + "'s remaining health is " +
                                  str(enemy.health) + "!\n")
                # call upon leeching when there is damage from the enemy
                if self.leeching != 0 and self.health < self.health_max:
                    self.health = self.leeching_health(damage, enemy)

        # returns self.health to be used by the do_damage function
        return self.health

    def do_damage_enemy(self, enemy, damage, break_defense_chance):
        """
        Function just like the do_damage_player but it is used instead for the enemy and gives message to the player
        on what damage they dealt and if they defeat the player
        :param enemy: enemy is the player
        :param damage: damage given to the player
        :param break_defense_chance: if the defense of the player broke
        """
        print('')  # space for terminal
        # for aesthetics in terminal
        print(ENEMY_TURN_BANNER)
        # if the defenses break
        if break_defense_chance == 1:
            # when the damage is equals to zero
            if damage == 0:
                type_print_effect(self.name + " barely scratched " +
                                  enemy.name + "!\n")
                type_print_effect(enemy.name + "'s Health is: " + str(enemy.health) + "\n")
                print('')  # space for terminal

            # when the defenses break but there is damage
            else:
                # enemy losses health with no defense
                enemy.health = enemy.health - damage
                type_print_effect(enemy.name + "'s defense has broken! " +
                                  self.name + " dealt " + str(damage) + " damage!\n")
                type_print_effect(enemy.name + "'s remaining health is " +
                                  str(enemy.health) + "!\n")
                print('')  # space for terminal

        # if the defenses did not break
        else:
            # if the damage is lower than the defense of the enemy
            if damage <= enemy.defense:
                type_print_effect(enemy.name + " defended all of " + self.name + " attacks!\n")
                type_print_effect(enemy.name + "'s remaining health is " +
                                  str(enemy.health) + "!\n")
                print('')  # space for terminal

            # if the damage exceeds the defense
            else:
                # damage is subtracted to defense, that is the updated damage
                damage_with_defense = damage - enemy.defense

                # enemy losses health with defense
                enemy.health = enemy.health - damage_with_defense

                type_print_effect(enemy.name + " defended a part of " + self.name + " attack!\n")
                type_print_effect(self.name + " dealt " + str(damage) + " damage!\n")
                type_print_effect(enemy.name + "'s remaining health is " +
                                  str(enemy.health) + "!\n")
                print('')  # space for terminal

    def leeching_health(self, damage, enemy):
        """
        Function for the leeching power in which the damage given by the character is transformed into the
        character's health. But if the leeching is higher than the damage, only the damage is transformed into the
        health
        Return: self.health
        """
        # calculates the missing health to prevent over health in a character
        health_missing = self.health_max - self.health

        # for aesthetics in terminal
        print('')
        print('=' * NUMBER_OF_DASHES + " LEECH EFFECT " + '=' * NUMBER_OF_DASHES)

        # executed if the health missing is less than the leech or damage
        if health_missing <= self.leeching <= damage or health_missing <= self.leeching > damage:
            self.health += health_missing
            type_print_effect(self.name + " successfully leeched " + str(health_missing) +
                              " health from " + enemy.name + " and gained full health!\n")
            type_print_effect(self.name + "'s health is currently at " + str(self.health) + ".\n")

        # executed when the health missing is greater than the leech or damage
        elif health_missing > self.leeching <= damage:
            self.health += self.leeching
            type_print_effect(self.name + " leeched " + str(self.leeching) +
                              " health from " + enemy.name + ".\n")
            type_print_effect(self.name + "'s health is currently at " + str(self.health) + ".\n")

        # executed when the health missing is greater than the leech but the leech is greater than the damage
        elif health_missing > self.leeching > damage or self.leeching > damage:
            self.health += damage
            type_print_effect(self.name + " leeched " + str(damage) +
                              " health from " + enemy.name + " with all possible damage given at this round.\n")
            type_print_effect(self.name + "'s health is currently at " + str(self.health) + ".\n")

        return self.health

    def character_death(self, enemy):
        """
        Function that gets two characters and determine if they die. If an enemy dies, the player gains additional stats
        If the player dies, game over
        :param enemy: for the function to get the enemy attributes
        """
        # if the enemy of the instance caller dies
        if enemy.health <= 0:
            # if the enemy dies
            if self.__class__ == Player:
                print('')  # space for terminal
                # for aesthetics in terminal
                print('=' * NUMBER_OF_DASHES + " ENEMY DEFEAT " + '=' * NUMBER_OF_DASHES)

                type_print_effect(enemy.name + " has been slain by " + self.name + '!\n')

            # when the player dies by various enemies
            else:
                print('')  # space for terminal
                # for aesthetics in terminal
                print('=' * NUMBER_OF_DASHES + " PLAYER DEFEAT " + '=' * NUMBER_OF_DASHES)

                type_print_effect(enemy.name + " has been slain by " + self.name + " with no mercy!\n")
                type_print_effect("Game over! Thank you so much for playing The Journey\n")

                # end the game when the player dies
                sys.exit()

    def level_up(self):
        """
        Function for the player to level up, letting them choose what they can upgrade from. This will also let
        the enemy revive themselves with upgraded stats.
        """
        # first check if the caller is the player, to give messages about upgrading
        if self.__class__ == Player:
            # for levelling up the character and gaining plus stats
            self.health = self.health_max + 1
            self.health_max = self.health_max + 1
            self.shield_bubble = self.shield_bubble_max + 1
            self.shield_bubble_max = self.shield_bubble_max + 1

            type_print_effect(self.name + " has levelled up! " + self.name + "'s health has increased to 1.\n")
            type_print_effect(self.name + " total health is: " + str(self.health) + "!\n")
            print('')  # space for terminal

    def enemy_level_up(self):
        """
        Function specifically for levelling up the enemy. It will level up all of their necessary stats for
        a harder battle with the player
        :return:
        """
        # for levelling up the enemy
        self.health = self.health_max + 1
        self.health_max = self.health_max + 1
        self.attack += 1
        self.leeching += 0.1
        self.defense += 0.5
        self.shield_bubble = self.shield_bubble_max + 0.5
        self.shield_bubble_max = self.shield_bubble_max + 0.5

        # debugging
        self.__repr__()

    def __repr__(self):
        """
        repr function to check each enemy mob as they upgrade through time
        :return:
        """
        print("NAME:", self.name)
        print("health:", self.health)
        print("health_max:", self.health_max)
        print("attack:", self.attack)
        print("double_damage:", self.double_damage)
        print("leeching:", self.leeching)
        print("defense:", self.defense)
        print("shield_bubble:", self.shield_bubble)

        print('')  # for terminal
        print("ultimate_levelup_bar:", self.ultimate_levelup_bar)
        print("ultimate_levelup_bar_per_attack:", self.ultimate_levelup_bar_per_attack)

        print('')  # for terminal
        print("levelup_bar:", self.levelup_bar)
        print("levelup_per_defeated_enemy:", self.levelup_per_defeated_enemy)
        print('')  # for terminal


# =========================================================
# SUB-CLASS: COMMON ENEMY
# =========================================================

class DeformedMutatedHuman(Character):
    """
    Subclass of characters, a common enemy
    """

    def __init__(self):
        super().__init__()

        self.name = 'Deformed Mutated Human'
        self.health = 10
        self.health_max = 10
        self.attack = 20
        self.double_damage = 0
        self.leeching = 0
        self.defense = 5
        self.shield_bubble = 5
        self.shield_bubble_max = 5
        self.ultimate_levelup_bar = 0
        self.ultimate_levelup_bar_per_attack = 0
        self.levelup_bar = 0
        self.levelup_per_defeated_enemy = 0


class MutatedHuman(Character):
    """
    Subclass of character, a common enemy
    """

    def __init__(self):
        super().__init__()

        self.name = 'Mutated Human'
        self.health = 20
        self.health_max = 20
        self.attack = 10
        self.double_damage = 0
        self.leeching = 0
        self.defense = 7
        self.shield_bubble = 0
        self.shield_bubble_max = 0
        self.ultimate_levelup_bar = 0
        self.ultimate_levelup_bar_per_attack = 0
        self.levelup_bar = 0
        self.levelup_per_defeated_enemy = 0


class LostWanderer(Character):
    """
    Subclass of character, a common enemy
    """

    def __init__(self):
        super().__init__()

        self.name = 'Lost Wanderer'
        self.health = 5
        self.health_max = 5
        self.attack = 20
        self.double_damage = 0
        self.leeching = 5
        self.defense = 7
        self.shield_bubble = 0
        self.shield_bubble_max = 0
        self.ultimate_levelup_bar = 0
        self.ultimate_levelup_bar_per_attack = 0
        self.levelup_bar = 0
        self.levelup_per_defeated_enemy = 0


class Chaser(Character):
    """
    Subclass of character, a common enemy
    """

    def __init__(self):
        super().__init__()

        self.name = 'Lost Wanderer'
        self.health = 15
        self.health_max = 15
        self.attack = 15
        self.double_damage = 0
        self.leeching = 2
        self.defense = 10
        self.shield_bubble = 0
        self.shield_bubble_max = 0
        self.ultimate_levelup_bar = 0
        self.ultimate_levelup_bar_per_attack = 0
        self.levelup_bar = 0
        self.levelup_per_defeated_enemy = 0


# =========================================================
# SUB-CLASS: PLAYER
# =========================================================

class Player(Character):
    """
    Subclass of Character and it has all the commands that the player can do
    """

    # initial stats of the player TODO: CHANGE LEECHING VALUE TO ZERO AFTER DEBUGGING, AS WELL AS SHIELD BUBBLE
    def __init__(self):
        super().__init__()

        # for the p.name instance to overwrite the values of the parent class
        self.name = ''
        self.health = 50
        self.health_max = 50
        self.attack = 10
        self.double_damage = 0.05
        self.leeching = 11
        self.defense = 7
        self.shield_bubble = 20
        self.shield_bubble_max = 20
        self.ultimate_levelup_bar = 20
        self.ultimate_levelup_bar_per_attack = 4
        self.levelup_bar = 30
        self.levelup_per_defeated_enemy = 5

    def random_enemy_encounter(self, common_enemy_dict):
        """
        Function for random enemies to fight the player
        """

        # each integer is equivalent to one type of enemy
        random_enemy = random.randint(1, RANDOM_ENEMY_INTEGER)

        # the if statement messages are here for organization so that these messages should appear first
        # before the player commands attack mode
        if random_enemy == DEFORMED_MUTATED_HUMAN:
            type_print_effect("A " + 'Deformed Mutated Human' + " has spotted you!\n")
            print('')  # space for terminal

        elif random_enemy == MUTATED_HUMAN:
            type_print_effect("A " + 'Mutated Human' + " screeched as it notices your movement!\n")
            print('')  # space for terminal

        elif random_enemy == LOST_WANDERER:
            type_print_effect("The sound of a " + 'Lost Wanderer' + " echoed through the wind. And it has "
                                                                    "caught your attention!\n")
            print('')  # space for terminal

        elif random_enemy == CHASER:
            type_print_effect("A vicious " + 'Chaser' + " has smelled your scent. It suddenly sprinted "
                                                        "towards your direction!\n")
            print('')  # space for terminal

        self.player_commands_attack_mode(random_enemy, common_enemy_dict)

    def attack(self, random_enemy, common_enemy_dict):
        """
        Player attack using the .do_damage then if the player has leeching, call upon .leeching
        :parameter - random_enemy = for the function to see what enemy the player will face
        :parameter - common_enemy_dict = for the function to get the enemy attributes
        :parameter - flee_chance = an integer from the flee function that will let the player escape, but if they failed
        it will activate attack here
        """

        # if statement stating what enemy the player will encounter
        if random_enemy == DEFORMED_MUTATED_HUMAN:

            # lets the player attack first and .do_damage returns health to be analyzed here
            print("HEALTH OF ENEMY IN ENCOUNTER IS ", common_enemy_dict['deformed_mutated_human'].health)
            enemy_health = self.do_damage_with_shield_bubble(common_enemy_dict['deformed_mutated_human'])

            # if the enemy dies when their health is zero
            if enemy_health <= 0:
                # message prompt about death of enemy
                self.character_death(common_enemy_dict['deformed_mutated_human'])

                # lets the enemy revive themselves and player to level up themselves
                self.revive_enemy_and_level_them_up_alongside_player(common_enemy_dict)

                # to cut the loop of still going into attack mode when the enemy dies
                self.player_commands(common_enemy_dict)

            # if enemy is not yet death it will prompt the enemy to do revenge attack
            else:
                # the enemy will do counter revenge
                self.enemy_attack(random_enemy, common_enemy_dict)

        # same formula from above, just with different enemies
        elif random_enemy == MUTATED_HUMAN:
            enemy_health = self.do_damage_with_shield_bubble(common_enemy_dict['mutated_human'])
            if enemy_health <= 0:
                self.character_death(common_enemy_dict['mutated_human'])
                self.revive_enemy_and_level_them_up_alongside_player(common_enemy_dict)
                self.player_commands(common_enemy_dict)
            else:
                self.enemy_attack(random_enemy, common_enemy_dict)

        elif random_enemy == LOST_WANDERER:
            enemy_health = self.do_damage_with_shield_bubble(common_enemy_dict['lost_wanderer'])
            if enemy_health <= 0:
                self.character_death(common_enemy_dict['lost_wanderer'])
                # lets the enemy revive themselves and player to level up themselves
                self.revive_enemy_and_level_them_up_alongside_player(common_enemy_dict)
                self.player_commands(common_enemy_dict)
            else:
                self.enemy_attack(random_enemy, common_enemy_dict)

        elif random_enemy == CHASER:
            enemy_health = self.do_damage_with_shield_bubble(common_enemy_dict['chaser'])
            if enemy_health <= 0:
                self.character_death(common_enemy_dict['chaser'])
                # lets the enemy revive themselves and player to level up themselves
                self.revive_enemy_and_level_them_up_alongside_player(common_enemy_dict)
                self.player_commands(common_enemy_dict)
            else:
                self.enemy_attack(random_enemy, common_enemy_dict)

    def enemy_attack(self, random_enemy, common_enemy_dict):
        """
        Function that activates when the player chose flee in the commands but failed to escape,
        the enemy will attack the player first as a punishment.

        This also activates after the player attacks the enemy but the enemy is still alive, it does revenge attack
        :param random_enemy: to see what enemy will face the player
        :param common_enemy_dict: to let the function access the attributes of each enemy
        """

        # if statement stating what enemy the player will encounter
        if random_enemy == DEFORMED_MUTATED_HUMAN:
            # the enemy will do counter revenge
            common_enemy_dict['deformed_mutated_human'].do_damage_with_shield_bubble(self)
            # if the player died from the damage, it will end the game with a message
            common_enemy_dict['deformed_mutated_human'].character_death(self)
            # if the player did not die, let the player choose their next command in attack mode
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        # same formula from above, just with different enemies
        elif random_enemy == MUTATED_HUMAN:
            common_enemy_dict['mutated_human'].do_damage_with_shield_bubble(self)
            common_enemy_dict['mutated_human'].character_death(self)
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        elif random_enemy == LOST_WANDERER:
            common_enemy_dict['lost_wanderer'].do_damage_with_shield_bubble(self)
            common_enemy_dict['lost_wanderer'].character_death(self)
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        elif random_enemy == CHASER:
            common_enemy_dict['chaser'].do_damage_with_shield_bubble(self)
            common_enemy_dict['chaser'].character_death(self)
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)

    def revive_enemy_and_level_them_up_alongside_player(self, common_enemy_dict):
        """
        This activates when the player defeats a common enemy. It lets all of the enemies level up all of their stats
        for a harder game in the long run. It also levels up the player
        :return:
        """
        # let the user level up
        self.level_up()

        # let all common enemies level up
        common_enemy_dict['deformed_mutated_human'].enemy_level_up()
        common_enemy_dict['mutated_human'].enemy_level_up()
        common_enemy_dict['lost_wanderer'].enemy_level_up()
        common_enemy_dict['chaser'].enemy_level_up()

    def move(self, common_enemy_dict):
        """
        Function when a player moves, uses random integer to determine the number of steps the player takes
        One out of an integer chance that the player will encounter an enemy while moving
        """
        # probablity for enemy to show up while moving based on the constant
        enemy_possibility = random.randint(1, ENEMY_POSSIBILITY)

        # how many steps the player can take
        number_of_moves = random.randint(1, NUMBER_OF_MOVES)

        # if the player encounters an enemy
        if enemy_possibility == 1:
            # call upon the random_enemy_encounter to see what enemy the player will face off
            self.random_enemy_encounter(common_enemy_dict)
        elif enemy_possibility == 2:
            type_print_effect(self.name + " has nearly missed an enemy, and has moved " + str(number_of_moves)
                              + " steps.\n")
        elif enemy_possibility == 3:
            type_print_effect(self.name + " sneakily moved " + str(number_of_moves)
                              + " steps away from a monster.\n")
        else:
            type_print_effect(self.name + " has moved " + str(number_of_moves) + " steps.\n")
        print('')  # for spacing in the terminal

    def flee(self, random_enemy, common_enemy_dict):
        """
        A function only found while attack mode is one, a one in integer chance for the character to flee to prevent
        them from dying
        """
        flee_chance = random.randint(1, FLEE_POSSIBILITY)

        if flee_chance == 1:
            type_print_effect("You successfully escaped the enemy!\n")
            print('')
            self.player_commands(common_enemy_dict)
        else:
            type_print_effect('You failed to escape.\n')
            self.enemy_attack(random_enemy, common_enemy_dict)

    def status(self, random_enemy, common_enemy_dict, who_called_me):
        """
        Function that shows the current status (health, attack damage, etc) of the user's character
        """
        print("Health: " + str(self.health) + "   |   " +
              "Attack: " + str(self.attack) + "   |   " +
              "Double Damage: " + self.double_damage_percentage)

        print("Leeching: " + str(self.leeching) + "  |   " +
              "Defense: " + str(self.defense) + "   |   " +
              "Shield Bubble: " + str(self.shield_bubble))

        print("Ultimate Level Up Bar: " + str(self.ultimate_levelup_bar))
        print("Ultimate Level Up Bar Per Attack: " + str(self.ultimate_levelup_bar_per_attack))
        print("Level Up Bar: " + str(self.levelup_bar))
        print('')  # space for terminal

        # used when the player is in the middle of fighting a mob and chose status, it will go automatically to
        # attack mode to not let the player escape the loop
        if who_called_me == 'attack_mode':
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)
            print('')  # for spacing in the terminal

        print('')  # for spacing in the terminal

    # TODO: add player status
    def help_game(self, common_enemy_dict, random_enemy, who_called_me):
        """
        Function about all the information that the player wants to know
        """
        # list for all the commands that the player can do
        commands = [
            'a = attack',
            'b = move',
            'c = status',
            'd = help',
            'e = quit',
            'f = flee'
        ]

        # to be used in the dictionary as grouping
        enemy = [
            'a = Common Enemies',
            'b = Uncommon Enemies',
            'c = Allies'
        ]

        common_enemy = [
            'a = Deformed Mutating Human',
            'b = Mutated Human',
            'c = Lost Wanderer',
            'd = Chaser'
        ]
        print("This is the help section. What do you want to know about?")
        print("Please press the appropriate letter of the information you want to know about.")
        print('')

        #  Dictionary of information that the player can access
        help_list = ["a = Commands", "b = Enemies"]

        # list for the user to see
        print(help_list)

        # asks the user which topic do they need help with and lowercase for sanitation
        print('')
        player_chosen_help_command = input_print_effect('Which criteria do you want to choose? ').lower()
        print('')

        # if statement to implement what the player has chosen from
        # a for the commands
        if player_chosen_help_command == 'a':
            print(commands)
            # space for terminal
            print('')
            # subset for the user to be asked what specific command they want to know plus lowercase for sanitation
            chosen_help_specific_command = input_print_effect('What command do you want to learn more? ').lower()

            # where the player will see all commands, below this code are just for looping through this function
            self.help_commands(chosen_help_specific_command, random_enemy, common_enemy_dict, who_called_me)

            # asked at the end of the submain commands section for the player to choose if they still want to know
            # more information on the commands subtopic or go back to the main topic
            print('')  # space terminal
            print('=' * NUMBER_OF_DASHES + " END OF COMMAND SECTION " + '=' * NUMBER_OF_DASHES)
            print('')  # space terminal

            # end statement for the user to see when they are inside the commands database
            type_print_effect("Do you want to dive further into knowing more about different commands?\n")
            type_print_effect("Or go back to the main help section?\n")
            type_print_effect("Press y to stick to commands and n for no.\n")
            type_print_effect("Or press b to go back to the main help section.\n")
            ask_commands_again = input_print_effect("Please press the appropriate letter. ").lower()
            print('')

            # while loop when the player is inside the command database for them to repeat over and over if they
            # like
            while True:
                # if they chose to learn more
                if ask_commands_again == 'y':
                    # shows the user the exact same thing earlier for them to choose what they want to learn more
                    # for the user to see all types of commands
                    print(commands)
                    # space for terminal
                    print('')
                    # subset for the user to be asked what specific command they want to know plus lowercase for
                    # sanitation
                    chosen_help_specific_command = input_print_effect(
                        'What command do you want to learn more? ').lower()

                    # where the player will see all commands, below this code are just for looping through this function
                    self.help_commands(chosen_help_specific_command, random_enemy, common_enemy_dict, who_called_me)

                    # asked at the end of the submain enemies section for the player to choose if they still want to
                    # know more information on the enemies subtopic or go back to the main topic
                    print('')  # space terminal
                    print('=' * NUMBER_OF_DASHES + " END OF COMMAND SECTION " + '=' * NUMBER_OF_DASHES)
                    print('')  # space terminal

                    # end statement for the user to see when they are inside the enemy database
                    type_print_effect("Press y to stick to commands and n for no.\n")
                    type_print_effect("Or press b to go back to the main help section.\n")
                    ask_commands_again = input_print_effect("Please press the appropriate letter. ").lower()
                    print('')

                # when the player choses no
                elif ask_commands_again == 'n':
                    # to end the help loop and let the player choose another command besides help
                    
                    # used when the player is in the middle of fighting a mob and chose status, 
                    # it will go automatically to
                    # attack mode to not let the player escape the loop
                    if who_called_me == 'attack_mode':
                        self.player_commands_attack_mode(random_enemy, common_enemy_dict)
                        print('')  # for spacing in the terminal
                    else:
                        self.player_commands(common_enemy_dict)
                    
                # when the player wants to go back to the main section
                elif ask_commands_again == 'b':
                    self.help_game(common_enemy_dict, random_enemy, who_called_me)

                else:
                    # fencepost solution
                    type_print_effect("Invalid input. Please press the appropriate letter.\n")
                    print('')  # space terminal
                    type_print_effect("Press y to stick to commands and n for no.\n")
                    type_print_effect("Or press b to go back to the main help section.\n")
                    ask_commands_again = input_print_effect("Please press the appropriate letter. ").lower()
                    print('')

        # for when the player chooses enemies in the main help section
        elif player_chosen_help_command == 'b':
            # for the user to see all types of enemies
            print(enemy)
            # space for terminal
            print('')
            # subset for the user to be asked what specific enemy they want to know plus lowercase for sanitation
            chosen_enemy_help = input_print_effect('What enemy do you want to learn more? ').lower()
            print('')  # space for terminal

            # where the player will see the enemies, below this code are just for looping through this function
            self.help_enemies(chosen_enemy_help, common_enemy, random_enemy, common_enemy_dict, who_called_me)

            # asked at the end of the submain enemies section for the player to choose if they still want to know
            # more information on the enemies subtopic or go back to the main topic
            print('')  # space terminal
            print('=' * NUMBER_OF_DASHES + " END OF ENEMY SECTION " + '=' * NUMBER_OF_DASHES)
            print('')  # space terminal

            # end statement for the user to see when they are inside the enemy database
            type_print_effect("Do you want to dive further into knowing more about different enemies?\n")
            type_print_effect("Or go back to the main help section?\n")
            type_print_effect("Press y to stick to enemies and n for no.\n")
            type_print_effect("Or press b to go back to the main help section.\n")
            ask_enemies_again = input_print_effect("Please press the appropriate letter. ").lower()
            print('')

            # while loop when the player is inside the enemy database for them to repeat over and over if they
            # like
            while True:
                # if they chose to learn more
                if ask_enemies_again == 'y':
                    # shows the user the exact same thing earlier for them to choose what they want to learn more
                    # for the user to see all types of enemies
                    print(enemy)
                    print('')  # space for terminal
                    chosen_enemy_help = input_print_effect('What enemy do you want to learn more? ').lower()
                    print('')  # space for terminal

                    # chosen enemy help will go inside prompting a new if statement to be executed inside help_enemies
                    self.help_enemies(chosen_enemy_help,  common_enemy, random_enemy, common_enemy_dict, who_called_me)

                    print('')  # space terminal
                    print('=' * NUMBER_OF_DASHES + " END OF ENEMY SECTION " + '=' * NUMBER_OF_DASHES)
                    print('')  # space terminal

                    # asks the user again if they still want to stick
                    type_print_effect("Press y to stick to enemies and n for no.\n")
                    type_print_effect("Or press b to go back to the main help section.\n")
                    ask_enemies_again = input_print_effect("Please press the appropriate letter. ").lower()
                    print('')

                # when the player choses no
                elif ask_enemies_again == 'n':
                    # to end the help loop and let the player choose another command besides help

                    # used when the player is in the middle of fighting a mob and chose status, 
                    # it will go automatically to
                    # attack mode to not let the player escape the loop                    
                    if who_called_me == 'attack_mode':
                        self.player_commands_attack_mode(random_enemy, common_enemy_dict)
                        print('')  # for spacing in the terminal
                    else:
                        self.player_commands(common_enemy_dict)

                # when the player wants to go back to the main section
                elif ask_enemies_again == 'b':
                    self.help_game(common_enemy_dict, random_enemy, who_called_me)

                else:
                    # fencepost solution
                    type_print_effect("Invalid input. Please press the appropriate letter.\n")
                    print('')  # space terminal
                    type_print_effect("Press y to stick to enemies and n for no.\n")
                    type_print_effect("Or press b to go back to the main help section.\n")
                    ask_enemies_again = input_print_effect("Please press the appropriate letter. ").lower()
                    print('')

        # use for cleaner terminal reading at the end of each information given
        print('')  # space terminal
        print('=' * NUMBER_OF_DASHES + " END OF HELP SECTION " + '=' * NUMBER_OF_DASHES)
        print('')  # space terminal

    def help_commands(self, chosen_help_specific_command, random_enemy, common_enemy_dict, who_called_me):
        # for attack
        if chosen_help_specific_command == 'a':
            print('')  # space terminal
            print('=' * NUMBER_OF_DASHES + " COMMAND DESCRIPTION " + '=' * NUMBER_OF_DASHES)
            print('')  # space terminal
            print("Command for the player to attack.")
            print("Damage is based on the current weapon that the player is holding.")

        # for move
        elif chosen_help_specific_command == 'b':
            print('')  # space terminal
            print('=' * NUMBER_OF_DASHES + " COMMAND DESCRIPTION " + '=' * NUMBER_OF_DASHES)
            print('')  # space terminal
            print("Command for the player to move.")
            print("There is a small percentage that the player will encounter an enemy while moving.")

        # for status
        elif chosen_help_specific_command == 'c':
            print('')  # space terminal
            print('=' * NUMBER_OF_DASHES + " COMMAND DESCRIPTION " + '=' * NUMBER_OF_DASHES)
            print('')  # space terminal
            print("Command for the player to see their character's status.")

        # for help section
        elif chosen_help_specific_command == 'd':
            print('')  # space terminal
            print('=' * NUMBER_OF_DASHES + " COMMAND DESCRIPTION " + '=' * NUMBER_OF_DASHES)
            print('')  # space terminal
            print("Command for the player to see the help section of the game.")

        # for quitting the game
        elif chosen_help_specific_command == 'e':
            print('')  # space terminal
            print('=' * NUMBER_OF_DASHES + " COMMAND DESCRIPTION " + '=' * NUMBER_OF_DASHES)
            print('')  # space terminal
            print("Command for the player to quit the game.")

        # for fleeing
        elif chosen_help_specific_command == 'f':
            print('')  # space terminal
            print('=' * NUMBER_OF_DASHES + " COMMAND DESCRIPTION " + '=' * NUMBER_OF_DASHES)
            print('')  # space terminal
            print("Only available when an enemy has approached the player.")
            print('There is a percentage that the flee will be successful, if it fails the enemy')
            print('will attack the player for that turn.')

        # when invalid input
        else:
            print('Invalid input. Please press the aproppriate letter.')
            print('')
            self.help_game(common_enemy_dict, random_enemy, who_called_me)

    def help_enemies(self, chosen_enemy_help,  common_enemy, random_enemy, common_enemy_dict, who_called_me):
        """
        Sub function of help that has the information for all the enemies so the help function is not overcrowded
        with lines of code
        """
        # for the common enemies
        if chosen_enemy_help == 'a':
            # for the user to see all common enemies possible
            print(common_enemy)
            # space for terminal
            print('')
            # subset for the user to be asked what specific common enemy they want to know plus lowercase for
            # sanitation
            chosen_common_enemy_help = input_print_effect('What enemy do you want '
                                                          'to learn more? ').lower()
            print('')  # space for terminal

            # neverending loop if they want to keep finding out about enemies
            while True:
                # for deformed mutated human
                if chosen_common_enemy_help == 'a':
                    # Used for aesthetics in the terminal
                    print('=' * NUMBER_OF_DASHES + " ENEMY STATS " + '=' * NUMBER_OF_DASHES)
                    print('')
                    # for gap for the player to see the stats for a while before the backstory
                    time.sleep(HELP_BACKSTORY_NEXT_TEXT)
                    # prints the stats first
                    print("Health: " + str(common_enemy_dict['deformed_mutated_human'].health) + "    |   " +
                          "Attack: " + str(common_enemy_dict['deformed_mutated_human'].attack) + "   |   " +
                          "Double Damage: " + common_enemy_dict['deformed_mutated_human'].double_damage_percentage)

                    print("Leeching: " + str(common_enemy_dict['deformed_mutated_human'].leeching) + "  |   " +
                          "Defense: " + str(common_enemy_dict['deformed_mutated_human'].defense) + "   |   " +
                          "Shield Bubble: " + str(common_enemy_dict['deformed_mutated_human'].shield_bubble))

                    # then prints the backstory
                    # plus cleanliness in the terminal
                    print('')
                    print('=' * NUMBER_OF_DASHES + " BACK STORY " + '=' * NUMBER_OF_DASHES)
                    print('')
                    type_print_effect("Once a human that came from Earth, this "
                                      "abomination is the result of countless\n")
                    type_print_effect("experiments that failed, leaving him a husk of his former self.\n")
                    type_print_effect("They no longer have any sort of consciousness. "
                                      "Instead, what's left is their pure\n")
                    type_print_effect('rage for what has become of them. They have lower '
                                      'health due to them being the \n')
                    type_print_effect('later stage in decomposition than the Mutated Human. '
                                      'However, they make up for it\n')
                    type_print_effect('by their sheer strength.\n')
                    type_print_effect('')
                    break  # to break the while loop

                # for mutated human
                elif chosen_common_enemy_help == 'b':
                    # Used for aesthetics in the terminal
                    print('=' * NUMBER_OF_DASHES + " ENEMY STATS " + '=' * NUMBER_OF_DASHES)
                    print('')
                    # for gap for the player to see the stats for a while before the backstory
                    time.sleep(HELP_BACKSTORY_NEXT_TEXT)
                    print("Health: " + str(common_enemy_dict['mutated_human'].health) + "    |   " +
                          "Attack: " + str(common_enemy_dict['mutated_human'].attack) + "   |   " +
                          "Double Damage: " + common_enemy_dict['mutated_human'].double_damage_percentage)

                    print("Leeching: " + str(common_enemy_dict['mutated_human'].leeching) + "  |   " +
                          "Defense: " + str(common_enemy_dict['mutated_human'].defense) + "   |   " +
                          "Shield Bubble: " + str(common_enemy_dict['mutated_human'].shield_bubble))

                    # then prints the backstory
                    # plus cleanliness in the terminal
                    print('')
                    print('=' * NUMBER_OF_DASHES + " BACK STORY " + '=' * NUMBER_OF_DASHES)
                    print('')
                    type_print_effect("It has the same sad fate as the Deformed Mutated Human.\n")
                    type_print_effect("The difference, however, is that the Mutated Human is a failed experiment,\n")
                    type_print_effect("that has been conducted quite recently. They have a small percentage\n")
                    type_print_effect('of their consciousness still intact, therefore making their suffering more\n')
                    type_print_effect('horrendous. They have higher health than the Deformed Mutated Human due to\n')
                    type_print_effect('them being recent test subjects. However, they have a higher defense than the\n')
                    type_print_effect('Deformed Mutated Human due to their intact body composition.\n')
                    type_print_effect('')
                    break  # to break the while loop

                # for lost wanderer
                elif chosen_common_enemy_help == 'c':
                    # Used for aesthetics in the terminal
                    print('=' * NUMBER_OF_DASHES + " ENEMY STATS " + '=' * NUMBER_OF_DASHES)
                    print('')
                    # for gap for the player to see the stats for a while before the backstory
                    time.sleep(HELP_BACKSTORY_NEXT_TEXT)
                    print("Health: " + str(common_enemy_dict['lost_wanderer'].health) + "    |   " +
                          "Attack: " + str(common_enemy_dict['lost_wanderer'].attack) + "   |   " +
                          "Double Damage: " + common_enemy_dict['lost_wanderer'].double_damage_percentage)

                    print("Leeching: " + str(common_enemy_dict['lost_wanderer'].leeching) + "  |   " +
                          "Defense: " + str(common_enemy_dict['lost_wanderer'].defense) + "   |   " +
                          "Shield Bubble: " + str(common_enemy_dict['lost_wanderer'].shield_bubble))

                    # then prints the backstory
                    # plus cleanliness in the terminal
                    # TODO: add the history about the incident in the main story line that caused lost
                    #  wanderers to escape the experiments
                    print('')
                    print('=' * NUMBER_OF_DASHES + " BACK STORY " + '=' * NUMBER_OF_DASHES)
                    print('')
                    type_print_effect("These are individuals that have escaped the experiments but have failed to\n")
                    type_print_effect("mitigate the effects, therefore making their body worse than the Deformed\n")
                    type_print_effect("and Mutated Humans. They have drastically low health due to the effects but\n")
                    type_print_effect('they have gained the ability to restore their health '
                                      'when attacking individuals.\n')
                    type_print_effect('Unlike the Mutated Humans the Lost Wanderers have lost their\n')
                    type_print_effect('consciousness due to them escaping a long time ago after the incident.\n')
                    type_print_effect('')
                    break  # to break the while loop

                # for chaser
                elif chosen_common_enemy_help == 'd':
                    # Used for aesthetics in the terminal
                    print('=' * NUMBER_OF_DASHES + " ENEMY STATS " + '=' * NUMBER_OF_DASHES)
                    print('')
                    # for gap for the player to see the stats for a while before the backstory
                    time.sleep(HELP_BACKSTORY_NEXT_TEXT)
                    # Used for aesthetics in the terminal
                    print('=' * NUMBER_OF_DASHES + " ENEMY STATS " + '=' * NUMBER_OF_DASHES)
                    print('')
                    # for gap for the player to see the stats for a while before the backstory
                    time.sleep(HELP_BACKSTORY_NEXT_TEXT)
                    print("Health: " + str(common_enemy_dict['chaser'].health) + "    |   " +
                          "Attack: " + str(common_enemy_dict['chaser'].attack) + "   |   " +
                          "Double Damage: " + common_enemy_dict['chaser'].double_damage_percentage)

                    print("Leeching: " + str(common_enemy_dict['chaser'].leeching) + "  |   " +
                          "Defense: " + str(common_enemy_dict['chaser'].defense) + "   |   " +
                          "Shield Bubble: " + str(common_enemy_dict['chaser'].shield_bubble))

                    # then prints the backstory
                    # plus cleanliness in the terminal
                    print('')
                    print('=' * NUMBER_OF_DASHES + " BACK STORY " + '=' * NUMBER_OF_DASHES)
                    print('')
                    type_print_effect("These are animals of different origins that have escaped the experiments.\n")
                    type_print_effect(
                        "They are similar to the lost wanderers. Their entire existence is solely based\n")
                    type_print_effect(" in finding nutrition to feed themselves as they decay faster than the\n")
                    type_print_effect('Deformed and Mutated Humans. Out of all the enemies that the player encounter\n')
                    type_print_effect('while walking, they have the most balanced stats and have also gained the\n')
                    type_print_effect('the leech ability as well as high defense from their tough exterior.\n')
                    type_print_effect('')
                    break  # to break the while loop

                else:
                    print('Invalid input. Please press the aproppriate letter.')
                    print('')

                    print(common_enemy)
                    # space for terminal
                    print('')
                    # subset for the user to be asked what specific common enemy they want to know plus lowercase for
                    # sanitation
                    chosen_common_enemy_help = input_print_effect('What enemy do you want '
                                                                  'to learn more? ').lower()
                    print('')  # space for terminal

        # TODO: add uncommon enemies later
        elif chosen_enemy_help == 'b':
            print('not yet done')

        else:  #
            print('Invalid input. Please press the appropriate letter.')
            print('')
            self.help_game(common_enemy_dict, random_enemy, who_called_me)

    def quit_game(self, common_enemy_dict):
        """
        Command that will quit the game when the player wants to
        """
        #  Asks the player if they want to quit for a second time to make sure it was not a mistake and lowercase
        # for sanitation
        ask_player_again = input_print_effect("Are you sure you want to exit? (Type y for yes, n for no) ").lower()

        while ask_player_again != '':
            if ask_player_again == 'y':
                type_print_effect(
                    'Thank you for playing my game! I hope you enjoyed my first ever Programming Project.')
                sys.exit()
            elif ask_player_again == 'n':
                print('')  # for spacing in the terminal
                self.player_commands(common_enemy_dict)

            else:
                type_print_effect("Invalid input\n")
                print('')  # for spacing in the terminal

                #  fencepost solution
                ask_player_again = input_print_effect(
                    "Are you sure you want to exit? (Type y for yes, n for no) ").lower()

    def player_commands(self, common_enemy_dict):
        """
        All commands that the player can do when there are no enemies
        """
        print('What action do you want to do? We have the following.')

        #  for the user to see
        command_list = ["a = attack", 'b = move', 'c = status', 'd = help', 'e = quit']
        print(command_list)

        # asks player for the command that they want to do plus lowercase for sanitation
        player_actions = input("Please press the appropriate letter "
                               "for the command that you want to do. ").lower()
        print('')  # for spacing in the terminal

        if player_actions == 'a':
            # player can't fight anybody in player_command mode, has to be in attack mode
            type_print_effect('There are no enemies in sight...so far.\n')
        elif player_actions == 'b':
            self.move(common_enemy_dict)
        elif player_actions == 'c':
            # to differentiate player_command_attack_mode from the normal player command
            # calls None for positional arguments because in passive mode there are no random enemies
            self.status(random_enemy=None, common_enemy_dict=None, who_called_me='passive_mode')
        elif player_actions == 'd':
            self.help_game(common_enemy_dict, random_enemy=None, who_called_me='passive_mode')
        elif player_actions == 'e':
            self.quit_game(common_enemy_dict)
        else:
            type_print_effect("Invalid input.\n")
            print('')  # for spacing in the terminal
            self.player_commands(common_enemy_dict)

    def player_commands_attack_mode(self, random_enemy, common_enemy_dict):
        """
        All commands that the player can do when the player encounters an enemy
        """
        print('What action do you want to do? We have the following.')

        #  for the user to see
        command_list = ["a = attack", 'b = FLEE', 'c = status', 'd = help', 'e = quit']
        print(command_list)

        # asks player for the command that they want to do plus lowercase for sanitation
        player_actions = input("Please press the appropriate letter "
                               "for the command that you want to do. ").lower()
        print('')  # for spacing in the terminal

        if player_actions == 'a':
            Player.attack(self, random_enemy, common_enemy_dict)
        elif player_actions == 'b':
            # an updated command that the player can do ONLY if they are in attack mode.
            # possibility for the player to run away
            self.flee(random_enemy, common_enemy_dict)
        elif player_actions == 'c':
            # to differentiate player_command_attack_mode from the normal player command
            self.status(random_enemy, common_enemy_dict, who_called_me='attack_mode')
        elif player_actions == 'd':
            self.help_game(common_enemy_dict, random_enemy=None, who_called_me='attack_mode')
        elif player_actions == 'e':
            self.quit_game(common_enemy_dict)
        else:
            type_print_effect("Invalid input.\n")
            print('')  # for spacing in the terminal
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)


# =========================================================
# NO NEED FOR EDITING
# =========================================================


if __name__ == '__main__':
    main()
