"""
File: rpgame.py
----------------------------------------------------------------------
This is a simple RPG program where a player can choose various actions and fight enemies

Milestone:
1. Prompt welcome message - done
2. Input Name - done
2. Finish introduction - done
3. Create character - done
4. Make character move, attack, defend - done
    a. make a set of moves that a player can do:
        - move done
        - attack - done
        - status - done
        - help - almost
        - flee - not yet
5. Make an enemy - done
6. Random occurence of enemy when player is walking - done
6. Make enemy fight the character - done
8. Make a scripted enemy
9. continue storyline
"""

import random  # used for moving and random events in the game
import sys  # used for the text effect
import time  # used to delay the texts for a few miliseconds

BOSS_NAME = '⊑⟒⍀?'
# TODO: Change the constants later after debugging
# ======================= POSSIBILITY CONSTANTS ======================= #
ENEMY_POSSIBILITY = 1  # constant for random_enemy_occurance based from 1 to an integer for the possibility of an enemy
# spawning
FLEE_POSSIBILITY = 3  # constant for flee function based from 1 to an integer for the possibility of the character
# fleeing
RANDOM_ENEMY_INTEGER = 1  # used for debugging in the random_enemy_occurance. Each integer
NUMBER_OF_MOVES = 10  # used to determine the number of steps possible for the player to do

# ======================= RANDOM ENEMY CONSTANTS ======================= #
# constants used for the random enemy function
DEFORMED_MUTATED_HUMAN = 1  # dedicated number for the monster deformed mutated human
MUTATED_HUMAN = 2  # dedicated number for the monster mutated human
LOST_WANDERER = 3  # dedicated number for the lost wanderer
CHASER = 4  # dedicated number for the chaser

# ======================= TEXT EFFECT CONSTANTS ======================= #
NEXT_TEXT_DURATION = 0.1  # constant used for having a gap in between text that have the typing effect
INPUT_AND_TEXT_EFFECT_DURATION = 0.001  # 0.05 normal speed

# ========================= AESTHETIC CONSTANTS ======================= #
NUMBER_OF_DASHES = 20  # used for the breakers found in the terminal when the user plays
HELP_BACKSTORY_NEXT_TEXT = 0.2  # similar with NEXT_TEXT_DURATION difference however is this is used


# for the help section after the stats of the enemy have been revealed


# =========================================================
# MAIN FUNCTION
# =========================================================


def main():
    # values in the classes are (from left to right):
    # name, health, max_health, attack, double_damage, leeching, defense, shield_bubble,
    # ultimate_levelup_bar, ultimate_levelup_bar_per_attack, levelup_bar, levelup_per_defeated_enemy

    #  handler for the character parent class and the minimum value of each stats that a character can have
    handler = Character('', 1, 1, 10, 0, 0, 0, 0, 0, 0, 0, 0)

    # initial stats of the player
    p = Player(50, 50, 15, 0.05, 0, 7, 0, 20, 4, 30, 5)

    # name input to get the name of the player
    p.name = input_print_effect('Before we start, what is your name? ')

    # welcome_message_and_introduction(p.name)
    debug_attack = input('Just Press Enter ')

    while debug_attack == '':
        p.player_commands()
        debug_attack = input('Just Press Enter  ')

    # first_chapter()


# =========================================================
# FUNCTION FROM MAIN
# =========================================================


def welcome_message_and_introduction(user_name):
    """
    Welcome message for the user to see and asks the user whether to start the game or not
    Return: user_name
    """
    type_print_effect("Welcome to the Journey.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect('You are an individual that suddenly woke up without any recollection.\n')
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect('Now you must understand what happened before you came to this place.\n')
    time.sleep(NEXT_TEXT_DURATION)

    # Asks the user for an input and the input of the user is turned into a lowercase to clean data
    start_game = input_print_effect('Type y to start or n to end the game ').lower()

    # If argument with the user's choices, if n, it will exit the program, anything other than y or n will
    # be taken as a sign to end the game, and y will prompt to start the introduction function
    while start_game != '':
        if start_game == 'y':
            introduction(user_name)
            break
        elif start_game == 'n':
            print('')  # space for terminal
            type_print_effect('Thank you for taking the time to check out my first Python Project.\n')
            time.sleep(NEXT_TEXT_DURATION)
            type_print_effect('This means a lot to me. Have a great day! :)')
            sys.exit()
        else:
            print('')  # space for terminal
            print('Invalid input. Please press the appropriate letter.')

            # Fencepost solution
            start_game = input_print_effect('Type y to start or n to end the game ').lower()


# def first_chapter():


# =========================================================
# HELPER FUNCTIONS
# =========================================================

#  TODO: kulang pa dito YUNG WEAPONS LAGYAN MO MAMAYA
def introduction(user_name):
    """
    Opening dialogue with Alicia, the first character that the player saw, she will guide the player to the dojo
    Pre-condition: Player starts the game
    Post-condition: Player has a name and is headed for the dojo
    """
    print('')  # For spacing from the start menu
    type_print_effect("Hey, wake up! Are you okay? Who are you? And what are you doing near my home!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Oh my, you have so many bruises! Let me tend your wounds and then let's talk.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("I'm Alicia by the way, its a good thing I found you here,\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("there isn't any hospitals or clinic here for hundreds of kilometers.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("The best bet you have right now is me, good thing I have a first aid kit.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("I forgot to even ask! What's your name?\n")

    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("That's a nice name, " + user_name + "\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("There we go, I patched your wounds. The problem now is where would you go?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("And do you remember how you got here? Or who you are?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Hey! What's that in your shoulder, I guess I missed a wound.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("You're one of them!!! I can't believe it. How did you wind up here? In the middle of nowhere?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("You're here to defeat " + BOSS_NAME + "\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("But you can't! You'll get yourself killed!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("But if you're one of them, I guess you're destined towards that goal? Destiny is so weird\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("I mean, who gets to decide what you should do? Is it the player? I guess not...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("The player is only looking at the screen right now, just watching our whole conversation.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Anyway, since I can see that you're one of them, I believe you can still remember how to "
                      "fight?\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Or how to use your power? I want to see how you release your power!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Don't you rememeber anything? Come on, just one move!\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("...\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Oh my, if that's the case, I think you should go to the nearby dojo.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("The sensei there would help you remember the once you've lost\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Before you go! I'll give you this to defend yourself.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("It's no longer safe ever since we've left Earth.\n")
    time.sleep(NEXT_TEXT_DURATION)
    type_print_effect("Goodluck out there " + user_name + "\n")


# =========================================================
# SUB-HELPER FUNCTIONS
# =========================================================

def type_print_effect(text):
    """
    This function takes print strings and change them to have a typing effect with the help of time
    sleep so that it has a delay, much like when someone is typing

    Parameter: text - the inputted text where it would be converted to a typing effect
    """

    for character in text:
        print(character, end='')
        sys.stdout.flush()
        time.sleep(INPUT_AND_TEXT_EFFECT_DURATION)


def input_print_effect(text):
    """
    This function is the same with text_print_effect, the difference is that this is used
    when a user inputs something and a message is prompted

    :param: text - the message with the input from the user
    :return: value - the answer that the user gave to be used by other functions
    """
    for character in text:
        print(character, end='')
        sys.stdout.flush()
        time.sleep(INPUT_AND_TEXT_EFFECT_DURATION)
    value = input()
    return value


# =========================================================
# PARENT CLASS
# =========================================================


class Character:
    """
    Parent Class for all of the stats of each character, as well as the player.
    This also has all the functions that each character can do
    """

    def __init__(self, name, health, max_health, attack, double_damage, leeching, defense, shield_bubble,
                 ultimate_levelup_bar, ultimate_levelup_bar_per_attack, levelup_bar, levelup_per_defeated_enemy):
        self.name = name
        self.health = health
        self.max_health = max_health
        self.attack = attack
        self.double_damage = double_damage
        self.leeching = leeching
        self.defense = defense
        self.shield_bubble = shield_bubble

        # stats for levelling up to gain your ultimate
        self.ultimate_levelup_bar = ultimate_levelup_bar
        self.ultimate_levelup_bar_per_attack = ultimate_levelup_bar_per_attack

        # stats for levelling up your character
        self.levelup_bar = levelup_bar
        self.levelup_per_defeated_enemy = levelup_per_defeated_enemy

        #  double damage converted to percentage for the user to see in the status command
        self.double_damage_percentage = "{0:.2%}".format(double_damage)

    def leeching(self, damage):  # TODO: CHECK LEECHING
        """
        Function for the leeching power in which the damage given by the character is transformed into the
        character's health
        Return: self.health
        """

        # if the current health is less than max health
        if self.health < self.max_health:
            # if the leeching points is less than the damage given, give the value of the self.leeching as the
            # additional health
            if self.leeching <= damage:
                self.health += self.leeching

            # if the self.leeching points is higher than the damage, give the value of the damage as the health
            # points
            elif self.leeching > damage:
                self.health += damage

        # used when the self.health is higher than the maximum health due to leeching
        if self.health > self.max_health:
            surplus_health = self.health - self.max_health
            self.health = self.health - surplus_health

        return self.health

    def do_damage(self, enemy):
        """
        Function for when the player attacks
        :param enemy: To lower the health of the enemy
        :return enemy.health: To be analyzed inside the attack function in an if statement
        """
        # damage of the character
        damage = random.randint(0, self.attack)

        # utilizing the defense, one in three chance that the defense will break
        break_defense_chance = random.randint(1, 3)

        # checks to see if the class that called the method is the player
        if self.__class__ == Player:
            # for aesthetics in terminal
            print('=' * NUMBER_OF_DASHES + " PLAYER'S TURN " + '=' * NUMBER_OF_DASHES)
            # if the defenses break
            if break_defense_chance == 1:
                # when the damage is equals to zero
                if damage == 0:
                    type_print_effect(enemy.name + " felt a scratch! " +
                                      self.name + " dealt " + str(damage) + " damage!\n")

                else:
                    # enemy losses health with no defense
                    enemy.health = enemy.health - damage
                    type_print_effect(enemy.name + "'s defense has broken! " +
                                      self.name + " dealt " + str(damage) + " damage!\n")
                    type_print_effect("The " + enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")

            # if it does not break
            else:
                # if the damage is lower than the defense of the enemy
                if damage <= enemy.defense:
                    type_print_effect(enemy.name + " has defended all of your attack!\n")
                    type_print_effect("The " + enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")

                # if the damage exceeds the defense
                else:
                    # used when the damage is larger than the defense
                    damage_with_defense = damage - enemy.defense

                    enemy.health = enemy.health - damage_with_defense

                    type_print_effect(enemy.name + " defended a part of " + self.name + " attack!\n")
                    type_print_effect(self.name + " dealt " + str(damage) + " damage!\n")
                    type_print_effect("The " + enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")

        # if the caller are the common enemies
        elif self.__class__ == DeformedMutatedHuman or self.__class__ == MutatedHuman \
                or self.__class__ == LostWanderer or self.__class__ == Chaser:
            print('')  # space for terminal
            # for aesthetics in terminal
            print('=' * NUMBER_OF_DASHES + " ENEMY'S TURN " + '=' * NUMBER_OF_DASHES)
            # if the defenses break
            if break_defense_chance == 1:
                # when the damage is equals to zero
                if damage == 0:
                    type_print_effect(self.name + " barely scratched " +
                                      enemy.name + "!\n")
                    type_print_effect(enemy.name + "'s Health is: " + str(enemy.health) + "\n")
                    print('')  # space for terminal

                # when the defenses break but there is damage
                else:
                    # enemy losses health with no defense
                    enemy.health = enemy.health - damage
                    type_print_effect(enemy.name + "'s defense has broken! " +
                                      self.name + " dealt " + str(damage) + " damage!\n")
                    type_print_effect(enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")
                    print('')  # space for terminal

            # if the defenses did not break
            else:
                # if the damage is lower than the defense of the enemy
                if damage <= enemy.defense:
                    type_print_effect(enemy.name + " defended all of " + self.name + " attacks!\n")
                    type_print_effect(enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")
                    print('')  # space for terminal

                # if the damage exceeds the defense
                else:
                    # damage is subtracted to defense, that is the updated damage
                    damage_with_defense = damage - enemy.defense

                    # enemy losses health with defense
                    enemy.health = enemy.health - damage_with_defense

                    type_print_effect(enemy.name + " defended a part of " + self.name + " attack!\n")
                    type_print_effect(self.name + " dealt " + str(damage) + " damage!\n")
                    type_print_effect(enemy.name + "'s remaining health is " +
                                      str(enemy.health) + "!\n")
                    print('')  # space for terminal

        # returns enemy health to be analyzed in an if statement inside the caller in attack function
        return enemy.health

    def character_death(self, enemy):
        """
        Function that gets two characters and determine if they die. If an enemy dies, the player gains additional stats
        If the player dies, game over
        :param enemy: for the function to get the enemy attributes
        """
        # if the enemy of the instance caller dies
        if enemy.health <= 0:
            # if the enemy dies
            if self.__class__ == Player:

                type_print_effect(enemy.name + " has been slain by " + self.name + '!\n')

                # used to revive the enemy's health
                enemy.health = enemy.max_health + 1
                enemy.max_health = enemy.max_health + 1

                # for levelling up the character and gaining plus health
                self.health = self.max_health + 1
                self.max_health = self.max_health + 1
                type_print_effect(self.name + " has levelled up! " + self.name + "'s health has increased to 1.\n")
                type_print_effect(self.name + " total health is: " + str(self.health) + "!\n")
                print('')  # space for terminal

                # to cut the loop of still going into attack mode when the enemy dies
                Player.player_commands(self)

            # when the player dies by various enemies
            else:
                type_print_effect(enemy.name + " has been slain by " + self.name + " with no mercy!\n")
                type_print_effect("Game over! Thank you so much for playing The Journey\n")

                # end the game when the player dies
                sys.exit()


# =========================================================
# SUB-CLASS: COMMON ENEMY
# =========================================================

class DeformedMutatedHuman(Character):
    """
    Subclass of characters, a common enemy
    """

    def __init__(self,
                 name='Deformed Mutated Human',
                 health=10,
                 max_health=10,
                 attack=20,
                 double_damage=0,
                 leeching=None,
                 defense=5,
                 shield_bubble=None,
                 ultimate_levelup_bar=None,
                 ultimate_levelup_bar_per_attack=None,
                 levelup_bar=None,
                 levelup_per_defeated_enemy=None):
        super().__init__(name,
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)


class MutatedHuman(Character):
    """
    Subclass of character, a common enemy
    """

    def __init__(self,
                 name='Mutated Human',
                 health=20,
                 max_health=20,
                 attack=10,
                 double_damage=0,
                 leeching=None,
                 defense=7,
                 shield_bubble=None,
                 ultimate_levelup_bar=None,
                 ultimate_levelup_bar_per_attack=None,
                 levelup_bar=None,
                 levelup_per_defeated_enemy=None):
        super().__init__(name,
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)


class LostWanderer(Character):
    """
    Subclass of character, a common enemy
    """

    def __init__(self,
                 name='Lost Wanderer',
                 health=5,
                 max_health=5,
                 attack=20,
                 double_damage=0,
                 leeching=5,
                 defense=7,
                 shield_bubble=None,
                 ultimate_levelup_bar=None,
                 ultimate_levelup_bar_per_attack=None,
                 levelup_bar=None,
                 levelup_per_defeated_enemy=None):
        super().__init__(name,
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)


class Chaser(Character):
    """
    Subclass of character, a common enemy
    """

    def __init__(self,
                 name='Chaser',
                 health=15,
                 max_health=15,
                 attack=15,
                 double_damage=0,
                 leeching=2,
                 defense=7,
                 shield_bubble=None,
                 ultimate_levelup_bar=None,
                 ultimate_levelup_bar_per_attack=None,
                 levelup_bar=None,
                 levelup_per_defeated_enemy=None):
        super().__init__(name,
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)


# =========================================================
# SUB-CLASS: PLAYER
# =========================================================

class Player(Character):
    """
    Subclass of Character and it has all the commands that the player can do
    """

    def __init__(self,
                 health,
                 max_health,
                 attack,
                 double_damage,
                 leeching,
                 defense,
                 shield_bubble,
                 ultimate_levelup_bar,
                 ultimate_levelup_bar_per_attack,
                 levelup_bar,
                 levelup_per_defeated_enemy):

        # grabbed the parent class for inheritance for its functions
        super().__init__("",
                         health,
                         max_health,
                         attack,
                         double_damage,
                         leeching,
                         defense,
                         shield_bubble,
                         ultimate_levelup_bar,
                         ultimate_levelup_bar_per_attack,
                         levelup_bar,
                         levelup_per_defeated_enemy)

        # for the p.name instance to overwrite the values of the parent class
        self.name = ''

    def random_enemy_encounter(self):
        """
        Function for random enemies to fight the player
        """

        # calling all of the common class enemy when the player walks with a one in third chance to encounter them
        # compiled into a dictionary for organization
        common_enemy_dict = {
            'deformed_mutated_human': DeformedMutatedHuman(),
            'mutated_human': MutatedHuman(),
            'lost_wanderer': LostWanderer(),
            'chaser': Chaser()
        }

        # each integer is equivalent to one type of enemy
        random_enemy = random.randint(1, RANDOM_ENEMY_INTEGER)

        # the if statement messages are here for organization so that these messages should appear first
        # before the player commands attack mode
        if random_enemy == DEFORMED_MUTATED_HUMAN:
            type_print_effect("A " + 'Deformed Mutated Human' + " has spotted you!\n")
            print('')  # space for terminal

        elif random_enemy == MUTATED_HUMAN:
            type_print_effect("A " + 'Mutated Human' + " screeched as it notices your movement!\n")
            print('')  # space for terminal

        elif random_enemy == LOST_WANDERER:
            type_print_effect("The sound of a " + 'Lost Wanderer' + " echoed through the wind. And it has "
                                                                    "caught your attention!\n")
            print('')  # space for terminal

        elif random_enemy == CHASER:
            type_print_effect("A vicious " + 'Chaser' + " has smelled your scent. It suddenly sprinted "
                                                        "towards your direction!\n")
            print('')  # space for terminal

        self.player_commands_attack_mode(random_enemy, common_enemy_dict)

    def attack(self, random_enemy, common_enemy_dict):
        """
        Player attack using the .do_damage then if the player has leeching, call upon .leeching
        """
        # if statement stating what enemy the player will encounter
        if random_enemy == DEFORMED_MUTATED_HUMAN:
            # lets the player attack first and .do_damage returns health to be analyzed here
            enemy_health = self.do_damage(common_enemy_dict['deformed_mutated_human'])
            # if the enemy dies
            if enemy_health <= 0:
                # let the enemy revive its stat and the player gains additional health, ends attack mode and goes
                # back to normal commands
                self.character_death(common_enemy_dict['deformed_mutated_human'])
            # if the enemy did not die
            else:
                # the enemy will do counter revenge
                common_enemy_dict['deformed_mutated_human'].do_damage(self)
                # if the player died from the damage, it will end the game with a message
                common_enemy_dict['deformed_mutated_human'].character_death(self)
                # if the player did not die, let the player choose their next command in attack mode
                self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        # same formula from above, just with different enemies
        elif random_enemy == MUTATED_HUMAN:
            enemy_health = self.do_damage(common_enemy_dict['mutated_human'])
            if enemy_health <= 0:
                self.character_death(common_enemy_dict['mutated_human'])
            else:
                common_enemy_dict['mutated_human'].do_damage(self)
                common_enemy_dict['mutated_human'].character_death(self)
                self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        elif random_enemy == LOST_WANDERER:
            enemy_health = self.do_damage(common_enemy_dict['lost_wanderer'])
            if enemy_health <= 0:
                self.character_death(common_enemy_dict['lost_wanderer'])
            else:
                common_enemy_dict['lost_wanderer'].do_damage(self)
                common_enemy_dict['lost_wanderer'].character_death(self)
                self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        elif random_enemy == CHASER:
            enemy_health = self.do_damage(common_enemy_dict['chaser'])
            if enemy_health <= 0:
                self.character_death(common_enemy_dict['chaser'])
            else:
                common_enemy_dict['chaser'].do_damage(self)
                common_enemy_dict['chaser'].character_death(self)
                self.player_commands_attack_mode(random_enemy, common_enemy_dict)

        # call upon leeching every time a character attacks and if the character has it
        if self.leeching != 0:
            self.health = self.leeching(self)

    def move(self):
        """
        Function when a player moves, uses random integer to determine the number of steps the player takes
        One out of an integer chance that the player will encounter an enemy while moving
        """
        # probablity for enemy to show up while moving based on the constant
        enemy_possibility = random.randint(1, ENEMY_POSSIBILITY)

        # how many steps the player can take
        number_of_moves = random.randint(1, NUMBER_OF_MOVES)

        # if the player encounters an enemy
        if enemy_possibility == 1:
            # call upon the random_enemy_encounter to see what enemy the player will face off
            self.random_enemy_encounter()
        elif enemy_possibility == 2:
            type_print_effect(self.name + " has nearly missed an enemy, and has moved " + str(number_of_moves)
                              + " steps.\n")
        elif enemy_possibility == 3:
            type_print_effect(self.name + " sneakily moved " + str(number_of_moves)
                              + " steps away from a monster.\n")
        else:
            type_print_effect(self.name + " has moved " + str(number_of_moves) + " steps.\n")
        print('')  # for spacing in the terminal

    @staticmethod
    # TODO: code flee
    def flee(self):
        """
        A function only found while attack mode is one, a one in integer chance for the character to flee to prevent
        them from dying
        """
        flee_chance = random.randint(1, FLEE_POSSIBILITY)
        return flee_chance

    def status(self, random_enemy, common_enemy_dict, who_called_me):
        """
        Function that shows the current status (health, attack damage, etc) of the user's character
        """
        print("Health: " + str(self.health) + "   |   " +
              "Attack: " + str(self.attack) + "   |   " +
              "Double Damage: " + self.double_damage_percentage)

        print("Leeching: " + str(self.leeching) + "  |   " +
              "Defense: " + str(self.defense) + "   |   " +
              "Shield Bubble: " + str(self.shield_bubble))

        print("Ultimate Level Up Bar: " + str(self.ultimate_levelup_bar))
        print("Ultimate Level Up Bar Per Attack: " + str(self.ultimate_levelup_bar_per_attack))
        print("Level Up Bar: " + str(self.levelup_bar))
        print('')  # space for terminal

        if who_called_me == 'attack_mode':
            self.player_commands_attack_mode(random_enemy, common_enemy_dict)
            print('')  # for spacing in the terminal

        print('')  # for spacing in the terminal

    @staticmethod
    def help_game():
        """
        Function about all the information that the player wants to know
        """
        # instance for the help game to track the stats of the enemies
        common_enemy_dict_help = {
            'deformed_mutated_human': DeformedMutatedHuman(),
            'mutated_human': MutatedHuman(),
            'lost_wanderer': LostWanderer(),
            'chaser': Chaser()
        }
        # list for all the
        commands = [
            'a = attack',
            'b = move',
            'c = status',
            'd = help',
            'e = quit'
            'f = flee'
        ]
        enemy = [
            'a = Deformed Mutating Human',
            'b = Mutated Human',
            'c = Lost Wanderer',
            'd = Chaser'
        ]

        type_print_effect("This is the help section. What do you want to know about?\n")

        #  Dictionary of information that the player can access
        help_list = ["a = Commands", "b = Enemies"]

        # list for the user to see
        print(help_list)

        # asks the user which topic do they need help with and lowercase for sanitation
        print('')
        player_chosen_help_command = input_print_effect('Which command do you want to choose? ').lower()

        # if statement to implement what the player has chosen from
        # a for the commands
        if player_chosen_help_command == 'a':
            print(commands)
            # space for terminal
            print('')
            # subset for the user to be asked what specific command they want to know plus lowercase for sanitation
            player_chosen_help_specific_command = input_print_effect('What command do you want to learn more? ').lower()
            print("-" * NUMBER_OF_DASHES)

            # for attack
            if player_chosen_help_specific_command == 'a':
                print("Command for the player to attack.")
                print("Damage is based on the current weapon that the player is holding.")
                print('')

            # for move
            elif player_chosen_help_specific_command == 'b':
                print("Command for the player to move.")
                print("There is a small percentage that the player will encounter an enemy while moving.")
                print('')

            # for status
            elif player_chosen_help_specific_command == 'c':
                print("Command for the player to see their character's status.")
                print('')

            # for help section
            elif player_chosen_help_specific_command == 'd':
                print("Command for the player to see the help section of the game.")
                print('')

            # for quitting the game
            elif player_chosen_help_specific_command == 'e':
                print("Command for the player to quit the game.")
                print('')

            # for fleeing
            elif player_chosen_help_specific_command == 'f':
                print("Only available when an enemy has approached the player.")
                print('There is a percentage that the flee will be successful, if it fails the enemy')
                print('will attack the player for that turn.')
                print('')

            # when invalid input
            else:
                print('Invalid input. Please press the aproppriate letter.')
                print('')
                Player.help_game()

        # for enemies
        elif player_chosen_help_command == 'b':

            # for the user to see all types of enemies
            print(enemy)
            # space for terminal
            print('')
            # subset for the user to be asked what specific enemy they want to know plus lowercase for sanitation
            player_chosen_enemy_command = input_print_effect('What enemy do you want to learn more? ').lower()

            # for deformed mutated human
            # FIXME: Change the print so that it represents the enemy and not various commands
            # Used for aesthetics in the terminal
            print('=' * NUMBER_OF_DASHES + " ENEMY STATS " + '=' * NUMBER_OF_DASHES)
            time.sleep(HELP_BACKSTORY_NEXT_TEXT)
            if player_chosen_enemy_command == 'a':
                # prints the stats first
                print("Health: " + str(common_enemy_dict_help['deformed_mutated_human'].health) + "   |   " +
                      "Attack: " + str(common_enemy_dict_help['deformed_mutated_human'].attack) + "   |   " +
                      "Double Damage: " + common_enemy_dict_help['deformed_mutated_human'].double_damage_percentage)

                print("Leeching: " + str(common_enemy_dict_help['deformed_mutated_human'].leeching) + "  |   " +
                      "Defense: " + str(common_enemy_dict_help['deformed_mutated_human'].defense) + "   |   " +
                      "Shield Bubble: " + str(common_enemy_dict_help['deformed_mutated_human'].shield_bubble))

                # then prints the backstory
                # plus cleanliness in the terminal
                print('=' * NUMBER_OF_DASHES + " BACK STORY " + '=' * NUMBER_OF_DASHES)
                type_print_effect("Once a human that came from Earth, this abomination is the result of countless\n")
                type_print_effect("experiments that failed, leaving him a husk of his former self.\n")
                type_print_effect("They no longer have any sort of consciousness. Instead, what's left is their pure\n")
                type_print_effect('rage for what has become of them. They have lower health due to them being the \n')
                type_print_effect('later stage in decomposition than the Mutated Human. However, they make up for it\n')
                type_print_effect('by their sheer strength.\n')
                type_print_effect('')

            # for mutated human
            elif player_chosen_enemy_command == 'b':
                print("Health: " + str(common_enemy_dict_help['mutated_human'].health) + "   |   " +
                      "Attack: " + str(common_enemy_dict_help['mutated_human'].attack) + "   |   " +
                      "Double Damage: " + common_enemy_dict_help['mutated_human'].double_damage_percentage)

                print("Leeching: " + str(common_enemy_dict_help['mutated_human'].leeching) + "  |   " +
                      "Defense: " + str(common_enemy_dict_help['mutated_human'].defense) + "   |   " +
                      "Shield Bubble: " + str(common_enemy_dict_help['mutated_human'].shield_bubble))

                # then prints the backstory
                # plus cleanliness in the terminal
                print('=' * NUMBER_OF_DASHES + " BACK STORY " + '=' * NUMBER_OF_DASHES)
                type_print_effect("It has the same sad fate as the Deformed Mutated Human.\n")
                type_print_effect("The difference, however, is that the Mutated Human is a failed experiment,\n")
                type_print_effect("that has been conducted quite recently. They have a small percentage\n")
                type_print_effect('of their consciousness still intact, therefore making their suffering more\n')
                type_print_effect('horrendous. They have higher health than the Deformed Mutated Human due to\n')
                type_print_effect('them being recent test subjects. However, they have a higher defense than the\n')
                type_print_effect('Deformed Mutated Human due to their intact body composition.\n')
                type_print_effect('')

            # for lost wanderer
            elif player_chosen_enemy_command == 'c':
                print("Health: " + str(common_enemy_dict_help['lost_wanderer'].health) + "   |   " +
                      "Attack: " + str(common_enemy_dict_help['lost_wanderer'].attack) + "   |   " +
                      "Double Damage: " + common_enemy_dict_help['lost_wanderer'].double_damage_percentage)

                print("Leeching: " + str(common_enemy_dict_help['lost_wanderer'].leeching) + "  |   " +
                      "Defense: " + str(common_enemy_dict_help['lost_wanderer'].defense) + "   |   " +
                      "Shield Bubble: " + str(common_enemy_dict_help['lost_wanderer'].shield_bubble))

                # then prints the backstory
                # plus cleanliness in the terminal
                print('=' * NUMBER_OF_DASHES + " BACK STORY " + '=' * NUMBER_OF_DASHES)
                type_print_effect("These are individuals that have escaped the experiments but have failed to\n")
                type_print_effect("mitigate\n")
                type_print_effect("that has been conducted quite recently, making the individual have a residue\n")
                type_print_effect('of their lives before the tragedy.\n')
                type_print_effect('')

            # for chaser
            elif player_chosen_enemy_command == 'd':
                print("Command for the player to see the help section of the game.")
                print('')
            elif player_chosen_enemy_command == 'e':
                print("Command for the player to quit the game.")
                print('')
            else:
                print('Invalid input. Please press the aproppriate letter.')

                # fencepost solution
                #  subset for the user to be asked what specific command they want to know plus
                #  lowercase for sanitation
                print('')
                Player.help_game()

        # use for cleaner terminal reading
        print('=' * NUMBER_OF_DASHES + " END OF HELP SECTION " + '=' * NUMBER_OF_DASHES)
        print('')

    def quit_game(self):
        """
        Command that will quit the game when the player wants to
        """
        #  Asks the player if they want to quit for a second time to make sure it was not a mistake and lowercase
        # for sanitation
        ask_player_again = input_print_effect("Are you sure you want to exit? (Type y for yes, n for no) ").lower()

        while ask_player_again != '':
            if ask_player_again == 'y':
                type_print_effect(
                    'Thank you for playing my game! I hope you enjoyed my first ever Programming Project.')
                sys.exit()
            elif ask_player_again == 'n':
                print('')  # for spacing in the terminal
                Player.player_commands(self)

            else:
                type_print_effect("Invalid input\n")
                print('')  # for spacing in the terminal

                #  fencepost solution
                ask_player_again = input_print_effect(
                    "Are you sure you want to exit? (Type y for yes, n for no) ").lower()

    def player_commands(self):
        """
        All commands that the player can do when there are no enemies
        """
        print('What action do you want to do? We have the following.')

        #  for the user to see
        command_list = ["a = attack", 'b = move', 'c = status', 'd = help', 'e = quit']
        print(command_list)

        # asks player for the command that they want to do plus lowercase for sanitation
        player_actions = input("Please press the appropriate letter "
                               "for the command that you want to do. ").lower()
        print('')  # for spacing in the terminal

        if player_actions == 'a':
            type_print_effect('There are no enemies in sight...so far.\n')
        elif player_actions == 'b':
            Player.move(self)
        elif player_actions == 'c':
            # to differentiate player_command_attack_mode from the normal player command
            # calls None for positional arguments because in passive mode there are no random enemies
            Player.status(self, random_enemy=None, common_enemy_dict=None, who_called_me='passive_mode')
        elif player_actions == 'd':
            Player.help_game()
        elif player_actions == 'e':
            Player.quit_game(self)
        else:
            type_print_effect("Invalid input.\n")
            print('')  # for spacing in the terminal
            Player.player_commands(self)

    def player_commands_attack_mode(self, random_enemy, common_enemy_dict):
        """
        All commands that the player can do when the player encounters an enemy
        """
        print('What action do you want to do? We have the following.')

        #  for the user to see
        command_list = ["a = attack", 'b = FLEE', 'c = status', 'd = help', 'e = quit']
        print(command_list)

        # asks player for the command that they want to do plus lowercase for sanitation
        player_actions = input("Please press the appropriate letter "
                               "for the command that you want to do. ").lower()
        print('')  # for spacing in the terminal

        if player_actions == 'a':
            Player.attack(self, random_enemy, common_enemy_dict)
        elif player_actions == 'b':
            # an updated command that the player can do ONLY if they are in attack mode.
            # possibility for the player to run away
            Player.flee(self)
        elif player_actions == 'c':
            # to differentiate player_command_attack_mode from the normal player command
            Player.status(self, random_enemy, common_enemy_dict, who_called_me='attack_mode')
        elif player_actions == 'd':
            Player.help_game()
        elif player_actions == 'e':
            Player.quit_game(self)
        else:
            type_print_effect("Invalid input.\n")
            print('')  # for spacing in the terminal
            Player.player_commands_attack_mode(self, random_enemy, common_enemy_dict)


# =========================================================
# NO NEED FOR EDITING
# =========================================================


if __name__ == '__main__':
    main()
